Index: git/drivers/media/platform/mxc/capture/Kconfig
===================================================================
--- git.orig/drivers/media/platform/mxc/capture/Kconfig	2016-06-15 15:00:07.609442351 +0200
+++ git/drivers/media/platform/mxc/capture/Kconfig	2016-06-15 15:00:09.789442320 +0200
@@ -33,6 +33,12 @@
 	---help---
 	  If you plan to use the adv7180 video decoder with your MXC system, say Y here.
 
+config MXC_TVIN_TVP5150
+	tristate "Texas Instruments TVP5150 TV Decoder Input support"
+	depends on !VIDEO_MXC_EMMA_CAMERA && I2C
+	---help---
+	  If you plan to use the tvp5150 video decoder with your MXC system, say Y here.
+
 choice
 	prompt "Select Overlay Rounting"
 	default MXC_IPU_DEVICE_QUEUE_SDC
Index: git/drivers/media/platform/mxc/capture/Makefile
===================================================================
--- git.orig/drivers/media/platform/mxc/capture/Makefile	2016-06-15 15:00:07.609442351 +0200
+++ git/drivers/media/platform/mxc/capture/Makefile	2016-06-15 15:00:09.789442320 +0200
@@ -18,4 +18,7 @@
 adv7180_tvin-objs := adv7180.o
 obj-$(CONFIG_MXC_TVIN_ADV7180) += adv7180_tvin.o
 
+tvp5150_tvin-objs := mxc_tvp5150.o
+obj-$(CONFIG_MXC_TVIN_TVP5150) += mxc_tvp5150.o
+
 obj-$(CONFIG_VIDEO_V4L2_MXC_INT_DEVICE) += v4l2-int-device.o
Index: git/drivers/media/platform/mxc/capture/mxc_tvp5150.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/drivers/media/platform/mxc/capture/mxc_tvp5150.c	2016-06-15 17:51:49.377294537 +0200
@@ -0,0 +1,1442 @@
+/*
+ * tvp5150 - Texas Instruments TVP5150A/AM1 video decoder driver
+ *
+ * Copyright (c) 2005,2006 Mauro Carvalho Chehab (mchehab@infradead.org)
+ * This code is placed under the terms of the GNU General Public License v2
+ */
+
+#define DEBUG
+
+#ifdef DEBUG
+  #define DRIVER_NAME "tvp5150"
+  #define TVP5150_DBG
+  #define DBG_PRINT(fmt, ...)   printk("%s:%s:"fmt, \
+                                        DRIVER_NAME, __func__, \
+                                        ##__VA_ARGS__);
+  #define DBG_ERROR(fmt, ...)   printk("%s:%s:ERROR:"fmt, \
+                                        DRIVER_NAME, __func__, \
+                                        ##__VA_ARGS__);
+#else
+  #define DBG_PRINT(fmt, ...)
+  #define DBG_ERROR(fmt, ...)
+#endif
+
+
+#include <linux/clk.h>
+#include <linux/i2c.h>
+#include <linux/slab.h>
+#include <linux/videodev2.h>
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <media/v4l2-chip-ident.h>
+#include <v4l2-int-device.h>
+#include <media/tvp5150.h>
+#include <linux/mfd/core.h>
+#include <linux/mfd/syscon.h>
+#include <linux/mfd/syscon/imx6q-iomuxc-gpr.h>
+#include <linux/regmap.h>
+
+#include "mxc_v4l2_capture.h"
+#include "tvp5150_reg.h"
+
+#define TVP5150_H_MAX           720
+#define TVP5150_V_MAX_525_60    480
+#define TVP5150_V_MAX_OTHERS    576
+#define TVP5150_MAX_CROP_LEFT   511
+#define TVP5150_MAX_CROP_TOP    127
+#define TVP5150_CROP_SHIFT        2
+
+static int debug;
+module_param(debug, int, 0);
+MODULE_PARM_DESC(debug, "Debug level (0-2)");
+
+static const struct i2c_device_id tvp5150_id[] = {
+	{"tvp5150", 0},
+	{},
+};
+
+MODULE_DEVICE_TABLE(i2c, tvp5150_id);
+
+static int tvp5150_probe(struct i2c_client *c, const struct i2c_device_id *id);
+static int tvp5150_remove(struct i2c_client *c);
+
+static struct i2c_driver tvp5150_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name  = "tvp5150",
+	},
+	.probe    = tvp5150_probe,
+	.remove   = tvp5150_remove,
+	.id_table = tvp5150_id,
+};
+
+/*! List of input video formats supported. The video formats is corresponding
+ * with v4l2 id in video_fmt_t
+ */
+typedef enum {
+	TVP5150_NTSC = 0,    /* 0x1 (M, J) NTSC ITU-R BT.601 */
+	TVP5150_PAL,         /* 0x3 (B, D, G, H, I, N) PAL ITU-R BT.601 */
+	TVP5150_PAL_M,       /* 0x5 (M) PAL ITU-R BT.601 */
+	TVP5150_PAL_N,       /* 0x7 PAL-Nc ITU-R BT.601 */
+	TVP5150_NTSC_443,    /* 0x9 NTSC 4.43 ITU-R BT.601 */
+	TVP5150_SECAM,       /* 0xB SECAM ITU-R BT.601 */
+	TVP5150_NOT_LOCKED,  /*!< Not locked on a signal. */
+} video_fmt_idx;
+
+/*! Number of video standards supported (including 'not locked' signal). */
+//#define TVP5150_STD_MAX  	(TVP5150_PAL + 1)
+
+/*! Video format structure. */
+typedef struct {
+	int  v4l2_id;       /*!< Video for linux ID. */
+	char name[16];      /*!< Name (e.g., "NTSC", "PAL", etc.) */
+	u16  raw_width;     /*!< Raw width. */
+	u16  raw_height;    /*!< Raw height. */
+	u16  active_width;  /*!< Active width. */
+	u16  active_height; /*!< Active height. */
+	int  frame_rate;    /*!< Frame rate. */
+} video_fmt_t;
+
+/*! Description of video formats supported.
+ *
+ *  PAL: raw=720x625, active=720x576.
+ *  NTSC: raw=720x525, active=720x480.
+ */
+static video_fmt_t video_fmts[] = {
+	{			/*! NTSC */
+		.v4l2_id = V4L2_STD_NTSC,
+		.name          = "NTSC",
+		.raw_width     = 720,  /* SENS_FRM_WIDTH */
+		.raw_height    = 525,  /* SENS_FRM_HEIGHT */
+		.active_width  = 720,  /* ACT_FRM_WIDTH plus 1 */
+		.active_height = 480,  /* ACT_FRM_WIDTH plus 1 */
+		.frame_rate    = 30,
+	},
+	{			/*! (B, D, G, H, I, N) PAL */
+		.v4l2_id       = V4L2_STD_PAL,
+		.name          = "PAL",
+		.raw_width     = 720,
+		.raw_height    = 625,
+		.active_width  = 720,
+		.active_height = 576,
+		.frame_rate    = 25,
+	},
+	/*
+	 * TODO complete video format
+	 */
+	{			/*! (M) PAL ITU-R BT.601 */
+		.v4l2_id       = V4L2_STD_PAL_M,
+		.name          = "PAL M",
+	},
+	{			/*! PAL-Nc ITU-R BT.601 */
+		.v4l2_id       = V4L2_STD_PAL_N | V4L2_STD_PAL_Nc,
+		.name          = "PAL-Nc",
+	},
+	{			/*! NTSC 4.43 ITU-R BT.601 */
+		.v4l2_id       = V4L2_STD_NTSC_443,
+		.name          = "NTSC 4.43",
+	},
+	{			/*! SECAM ITU-R BT.601 */
+		.v4l2_id       = V4L2_STD_SECAM,
+		.name          = "SECAM",
+	},
+
+	{			/*! Unlocked standard */
+		.v4l2_id       = V4L2_STD_ALL,
+		.name          = "Autodetect",
+		.raw_width     = 720,
+		.raw_height    = 625,
+		.active_width  = 720,
+		.active_height = 576,
+		.frame_rate    = 0,
+	},
+};
+
+/**
+ * Supported controls
+ * This hasn't been fully implemented yet.
+ * This is how it should work, though.
+ */
+static struct v4l2_queryctrl tvp5150_qctrl[] = {
+	{
+		.id = V4L2_CID_BRIGHTNESS,
+		.type          = V4L2_CTRL_TYPE_INTEGER,
+		.name          = "Brightness",
+		.minimum       = 0,   /* check this value */
+		.maximum       = 255, /* check this value */
+		.step          = 1,   /* check this value */
+		.default_value = 127, /* check this value */
+		.flags = 0,
+	}, {
+		.id = V4L2_CID_SATURATION,
+		.type          = V4L2_CTRL_TYPE_INTEGER,
+		.name          = "Saturation",
+		.minimum       = 0,   /* check this value */
+		.maximum       = 255, /* check this value */
+		.step          = 0x1, /* check this value */
+		.default_value = 127, /* check this value */
+		.flags = 0,
+	}
+};
+
+/**
+ */
+struct tvp5150 {
+  struct sensor_data       sen;     /* must be the first, used in mxc_v4l2_capture */
+  video_fmt_idx            video_idx;
+  u32                      input;
+  u32                      output;
+  int                      enable;
+  struct v4l2_int_device   int_dev;
+  struct v4l2_int_slave    slave;
+};
+
+/** **************************************************************************
+ *                             I2C transfert
+ ************************************************************************** */
+
+/*! Read one register from a i2c slave device.
+ *
+ *  @param *c			pointer to i2c client structure.
+ *  @param *reg		register in the device we wish to access.
+ *
+ *  @return		       0 if success, an error code otherwise.
+ */
+static inline int tvp5150_read(struct i2c_client *c, u8 reg)
+{
+	int val;
+
+	val = i2c_smbus_read_byte_data(c, reg);
+	if (val < 0) {
+		DBG_ERROR(KERN_ERR "i2cRead reg %02X error\n", reg);
+		return -1;
+	}
+	return val;
+}
+
+/*! Write one register of a i2c slave device.
+ *
+ *  @param *c			pointer to i2c client structure.
+ *  @param *reg		register in the device we wish to access.
+ *  @param val		value to write.
+ *
+ *  @return		       0 if success, an error code otherwise.
+ */
+static inline void tvp5150_write(struct i2c_client *c, u8 reg, u8 val)
+{
+	int ret;
+
+	ret = i2c_smbus_write_byte_data(c, reg, val);
+	if (ret < 0) {
+		DBG_ERROR("i2cWrite reg %02X error, val=%02x\n", reg, val);
+		return;
+	}
+	return;
+}
+
+static void dump_reg_range(struct i2c_client *c, char *s, u8 init,
+                           const u8 end, int max_line)
+{
+	int i = 0;
+
+	while (init != (u8)(end + 1)) {
+		if ((i % max_line) == 0) {
+			if (i > 0)
+				printk("\n");
+			printk("tvp5150: %s reg 0x%02x = ", s, init);
+		}
+		printk("%02x ", tvp5150_read(c, init));
+		init++;
+		i++;
+	}
+	printk("\n");
+}
+
+static int tvp5150_log_status(struct i2c_client *c)
+{
+	printk("tvp5150: Video input source selection #1 = 0x%02x\n",
+			tvp5150_read(c, TVP5150_VD_IN_SRC_SEL_1));
+	printk("tvp5150: Analog channel controls = 0x%02x\n",
+			tvp5150_read(c, TVP5150_ANAL_CHL_CTL));
+	printk("tvp5150: Operation mode controls = 0x%02x\n",
+			tvp5150_read(c, TVP5150_OP_MODE_CTL));
+	printk("tvp5150: Miscellaneous controls = 0x%02x\n",
+			tvp5150_read(c, TVP5150_MISC_CTL));
+	printk("tvp5150: Autoswitch mask= 0x%02x\n",
+			tvp5150_read(c, TVP5150_AUTOSW_MSK));
+	printk("tvp5150: Color killer threshold control = 0x%02x\n",
+			tvp5150_read(c, TVP5150_COLOR_KIL_THSH_CTL));
+	printk("tvp5150: Luminance processing controls #1 #2 and #3 = %02x %02x %02x\n",
+			tvp5150_read(c, TVP5150_LUMA_PROC_CTL_1),
+			tvp5150_read(c, TVP5150_LUMA_PROC_CTL_2),
+			tvp5150_read(c, TVP5150_LUMA_PROC_CTL_3));
+	printk("tvp5150: Brightness control = 0x%02x\n",
+			tvp5150_read(c, TVP5150_BRIGHT_CTL));
+	printk("tvp5150: Color saturation control = 0x%02x\n",
+			tvp5150_read(c, TVP5150_SATURATION_CTL));
+	printk("tvp5150: Hue control = 0x%02x\n",
+			tvp5150_read(c, TVP5150_HUE_CTL));
+	printk("tvp5150: Contrast control = 0x%02x\n",
+			tvp5150_read(c, TVP5150_CONTRAST_CTL));
+	printk("tvp5150: Outputs and data rates select = 0x%02x\n",
+			tvp5150_read(c, TVP5150_DATA_RATE_SEL));
+	printk("tvp5150: Configuration shared pins = 0x%02x\n",
+			tvp5150_read(c, TVP5150_CONF_SHARED_PIN));
+	printk("tvp5150: Active video cropping start = 0x%02x%02x\n",
+			tvp5150_read(c, TVP5150_ACT_VD_CROP_ST_MSB),
+			tvp5150_read(c, TVP5150_ACT_VD_CROP_ST_LSB));
+	printk("tvp5150: Active video cropping stop  = 0x%02x%02x\n",
+			tvp5150_read(c, TVP5150_ACT_VD_CROP_STP_MSB),
+			tvp5150_read(c, TVP5150_ACT_VD_CROP_STP_LSB));
+	printk("tvp5150: Genlock/RTC = 0x%02x\n",
+			tvp5150_read(c, TVP5150_GENLOCK));
+	printk("tvp5150: Horizontal sync start = 0x%02x\n",
+			tvp5150_read(c, TVP5150_HORIZ_SYNC_START));
+	printk("tvp5150: Vertical blanking start = 0x%02x\n",
+			tvp5150_read(c, TVP5150_VERT_BLANKING_START));
+	printk("tvp5150: Vertical blanking stop = 0x%02x\n",
+			tvp5150_read(c, TVP5150_VERT_BLANKING_STOP));
+	printk("tvp5150: Chrominance processing control #1 and #2 = %02x %02x\n",
+			tvp5150_read(c, TVP5150_CHROMA_PROC_CTL_1),
+			tvp5150_read(c, TVP5150_CHROMA_PROC_CTL_2));
+	printk("tvp5150: Interrupt reset register B = 0x%02x\n",
+			tvp5150_read(c, TVP5150_INT_RESET_REG_B));
+	printk("tvp5150: Interrupt enable register B = 0x%02x\n",
+			tvp5150_read(c, TVP5150_INT_ENABLE_REG_B));
+	printk("tvp5150: Interrupt configuration register B = 0x%02x\n",
+			tvp5150_read(c, TVP5150_INTT_CONFIG_REG_B));
+	printk("tvp5150: Video standard = 0x%02x\n",
+			tvp5150_read(c, TVP5150_VIDEO_STD));
+	printk("tvp5150: Chroma gain factor: Cb=0x%02x Cr=0x%02x\n",
+			tvp5150_read(c, TVP5150_CB_GAIN_FACT),
+			tvp5150_read(c, TVP5150_CR_GAIN_FACTOR));
+	printk("tvp5150: Macrovision on counter = 0x%02x\n",
+			tvp5150_read(c, TVP5150_MACROVISION_ON_CTR));
+	printk("tvp5150: Macrovision off counter = 0x%02x\n",
+			tvp5150_read(c, TVP5150_MACROVISION_OFF_CTR));
+	printk("tvp5150: ITU-R BT.656.%d timing(TVP5150AM1 only)\n",
+			(tvp5150_read(c, TVP5150_REV_SELECT) & 1) ? 3 : 4);
+	printk("tvp5150: Device ID = %02x%02x\n",
+			tvp5150_read(c, TVP5150_MSB_DEV_ID),
+			tvp5150_read(c, TVP5150_LSB_DEV_ID));
+	printk("tvp5150: ROM version = (hex) %02x.%02x\n",
+			tvp5150_read(c, TVP5150_ROM_MAJOR_VER),
+			tvp5150_read(c, TVP5150_ROM_MINOR_VER));
+	printk("tvp5150: Vertical line count = 0x%02x%02x\n",
+			tvp5150_read(c, TVP5150_VERT_LN_COUNT_MSB),
+			tvp5150_read(c, TVP5150_VERT_LN_COUNT_LSB));
+	printk("tvp5150: Interrupt status register B = 0x%02x\n",
+			tvp5150_read(c, TVP5150_INT_STATUS_REG_B));
+	printk("tvp5150: Interrupt active register B = 0x%02x\n",
+			tvp5150_read(c, TVP5150_INT_ACTIVE_REG_B));
+	printk("tvp5150: Status regs #1 to #5 = %02x %02x %02x %02x %02x\n",
+			tvp5150_read(c, TVP5150_STATUS_REG_1),
+			tvp5150_read(c, TVP5150_STATUS_REG_2),
+			tvp5150_read(c, TVP5150_STATUS_REG_3),
+			tvp5150_read(c, TVP5150_STATUS_REG_4),
+			tvp5150_read(c, TVP5150_STATUS_REG_5));
+
+	dump_reg_range(c, "Teletext filter 1",   TVP5150_TELETEXT_FIL1_INI,
+			TVP5150_TELETEXT_FIL1_END, 8);
+	dump_reg_range(c, "Teletext filter 2",   TVP5150_TELETEXT_FIL2_INI,
+			TVP5150_TELETEXT_FIL2_END, 8);
+
+	printk("tvp5150: Teletext filter enable = 0x%02x\n",
+			tvp5150_read(c, TVP5150_TELETEXT_FIL_ENA));
+	printk("tvp5150: Interrupt status register A = 0x%02x\n",
+			tvp5150_read(c, TVP5150_INT_STATUS_REG_A));
+	printk("tvp5150: Interrupt enable register A = 0x%02x\n",
+			tvp5150_read(c, TVP5150_INT_ENABLE_REG_A));
+	printk("tvp5150: Interrupt configuration = 0x%02x\n",
+			tvp5150_read(c, TVP5150_INT_CONF));
+	printk("tvp5150: VDP status register = 0x%02x\n",
+			tvp5150_read(c, TVP5150_VDP_STATUS_REG));
+	printk("tvp5150: FIFO word count = 0x%02x\n",
+			tvp5150_read(c, TVP5150_FIFO_WORD_COUNT));
+	printk("tvp5150: FIFO interrupt threshold = 0x%02x\n",
+			tvp5150_read(c, TVP5150_FIFO_INT_THRESHOLD));
+	printk("tvp5150: FIFO reset = 0x%02x\n",
+			tvp5150_read(c, TVP5150_FIFO_RESET));
+	printk("tvp5150: Line number interrupt = 0x%02x\n",
+			tvp5150_read(c, TVP5150_LINE_NUMBER_INT));
+	printk("tvp5150: Pixel alignment register = 0x%02x%02x\n",
+			tvp5150_read(c, TVP5150_PIX_ALIGN_REG_HIGH),
+			tvp5150_read(c, TVP5150_PIX_ALIGN_REG_LOW));
+	printk("tvp5150: FIFO output control = 0x%02x\n",
+			tvp5150_read(c, TVP5150_FIFO_OUT_CTRL));
+	printk("tvp5150: Full field enable = 0x%02x\n",
+			tvp5150_read(c, TVP5150_FULL_FIELD_ENA));
+	printk("tvp5150: Full field mode register = 0x%02x\n",
+			tvp5150_read(c, TVP5150_FULL_FIELD_MODE_REG));
+
+	dump_reg_range(c, "CC   data",   TVP5150_CC_DATA_INI,
+			TVP5150_CC_DATA_END, 8);
+
+	dump_reg_range(c, "WSS  data",   TVP5150_WSS_DATA_INI,
+			TVP5150_WSS_DATA_END, 8);
+
+	dump_reg_range(c, "VPS  data",   TVP5150_VPS_DATA_INI,
+			TVP5150_VPS_DATA_END, 8);
+
+	dump_reg_range(c, "VITC data",   TVP5150_VITC_DATA_INI,
+			TVP5150_VITC_DATA_END, 10);
+
+	dump_reg_range(c, "Line mode",   TVP5150_LINE_MODE_INI,
+			TVP5150_LINE_MODE_END, 8);
+	return 0;
+}
+
+/****************************************************************************
+			Basic functions
+ ****************************************************************************/
+
+static inline void tvp5150_selmux(struct tvp5150 *core)
+{
+	struct i2c_client *c = core->sen.i2c_client;
+	int opmode = 0;
+	int input = 0;
+	int val;
+/*
+	if ((core->output & TVP5150_BLACK_SCREEN) || !core->enable)
+		input = 8;
+*/
+	switch (core->input) {
+	case TVP5150_COMPOSITE1:
+		input |= 2;
+		/* fall through */
+	case TVP5150_COMPOSITE0:
+		break;
+	case TVP5150_SVIDEO:
+	default:
+		input |= 1;
+		break;
+	}
+
+	DBG_PRINT("Selecting video route: route input=%i, output=%i "
+			"=> tvp5150 input=%i, opmode=%i\n",
+			core->input, core->output,
+			input, opmode);
+
+	tvp5150_write(c, TVP5150_OP_MODE_CTL, opmode);
+	tvp5150_write(c, TVP5150_VD_IN_SRC_SEL_1, input);
+
+	/* Svideo should enable YCrCb output and disable GPCL output
+	 * For Composite and TV, it should be the reverse
+	 */
+	val = tvp5150_read(c, TVP5150_MISC_CTL);
+	if (val < 0) {
+		v4l2_err(c, "%s: failed with error = %d\n", __func__, val);
+		return;
+	}
+
+	if (core->input == TVP5150_SVIDEO)
+		val = (val & ~0x40) | 0x10;
+	else
+		val = (val & ~0x10) | 0x40;
+	tvp5150_write(c, TVP5150_MISC_CTL, val);
+};
+
+struct i2c_reg_value {
+	unsigned char reg;
+	unsigned char value;
+};
+
+/* Default values as sugested at TVP5150AM1 datasheet */
+static const struct i2c_reg_value tvp5150_init_default[] = {
+	{ /* 0x00 */ TVP5150_VD_IN_SRC_SEL_1     , 0x00 },
+	{ /* 0x01 */ TVP5150_ANAL_CHL_CTL        , 0x15 },
+	{ /* 0x02 */ TVP5150_OP_MODE_CTL         , 0x00 },
+	{ /* 0x03 */ TVP5150_MISC_CTL            , 0x01 },
+	{ /* 0x06 */ TVP5150_COLOR_KIL_THSH_CTL  , 0x10 },
+	{ /* 0x07 */ TVP5150_LUMA_PROC_CTL_1     , 0x60 },
+	{ /* 0x08 */ TVP5150_LUMA_PROC_CTL_2     , 0x00 },
+	{ /* 0x09 */ TVP5150_BRIGHT_CTL          , 0x80 },
+	{ /* 0x0a */ TVP5150_SATURATION_CTL      , 0x80 },
+	{ /* 0x0b */ TVP5150_HUE_CTL             , 0x00 },
+	{ /* 0x0c */ TVP5150_CONTRAST_CTL        , 0x80 },
+	{ /* 0x0d */ TVP5150_DATA_RATE_SEL       , 0x07 },
+	{ /* 0x0e */ TVP5150_LUMA_PROC_CTL_3     , 0x00 },
+	{ /* 0x0f */ TVP5150_CONF_SHARED_PIN     , 0x08 },
+	{ /* 0x11 */ TVP5150_ACT_VD_CROP_ST_MSB  , 0x00 },
+	{ /* 0x12 */ TVP5150_ACT_VD_CROP_ST_LSB  , 0x00 },
+	{ /* 0x13 */ TVP5150_ACT_VD_CROP_STP_MSB , 0x00 },
+	{ /* 0x14 */ TVP5150_ACT_VD_CROP_STP_LSB , 0x00 },
+	{ /* 0x15 */ TVP5150_GENLOCK             , 0x01 },
+	{ /* 0x16 */ TVP5150_HORIZ_SYNC_START    , 0x80 },
+	{ /* 0x18 */ TVP5150_VERT_BLANKING_START , 0x00 },
+	{ /* 0x19 */ TVP5150_VERT_BLANKING_STOP  , 0x00 },
+	{ /* 0x1a */ TVP5150_CHROMA_PROC_CTL_1   , 0x0c },
+	{ /* 0x1b */ TVP5150_CHROMA_PROC_CTL_2   , 0x14 },
+	{ /* 0x1c */ TVP5150_INT_RESET_REG_B     , 0x00 },
+	{ /* 0x1d */ TVP5150_INT_ENABLE_REG_B    , 0x00 },
+	{ /* 0x1e */ TVP5150_INTT_CONFIG_REG_B   , 0x00 },
+	{ /* 0x28 */ TVP5150_VIDEO_STD           , 0x00 },
+	{ /* 0x2e */ TVP5150_MACROVISION_ON_CTR  , 0x0f },
+	{ /* 0x2f */ TVP5150_MACROVISION_OFF_CTR , 0x01 },
+	{ /* 0xbb */ TVP5150_TELETEXT_FIL_ENA    , 0x00 },
+	{ /* 0xc0 */ TVP5150_INT_STATUS_REG_A    , 0x00 },
+	{ /* 0xc1 */ TVP5150_INT_ENABLE_REG_A    , 0x00 },
+	{ /* 0xc2 */ TVP5150_INT_CONF            , 0x04 },
+	{ /* 0xc8 */ TVP5150_FIFO_INT_THRESHOLD  , 0x80 },
+	{ /* 0xc9 */ TVP5150_FIFO_RESET          , 0x00 },
+	{ /* 0xca */ TVP5150_LINE_NUMBER_INT     , 0x00 },
+	{ /* 0xcb */ TVP5150_PIX_ALIGN_REG_LOW   , 0x4e },
+	{ /* 0xcc */ TVP5150_PIX_ALIGN_REG_HIGH  , 0x00 },
+	{ /* 0xcd */ TVP5150_FIFO_OUT_CTRL       , 0x01 },
+	{ /* 0xcf */ TVP5150_FULL_FIELD_ENA      , 0x00 },
+	{ /* 0xd0 */ TVP5150_LINE_MODE_INI       , 0x00 },
+	{ /* 0xfc */ TVP5150_FULL_FIELD_MODE_REG , 0x7f },
+	{ /* end of data */ 0xff,0xff
+	}
+};
+
+/* Default values as sugested at TVP5150AM1 datasheet */
+static const struct i2c_reg_value tvp5150_init_enable[] = {
+	{ TVP5150_CONF_SHARED_PIN  , 0x02 },
+	{ TVP5150_ANAL_CHL_CTL     , 0x15 },	/* Automatic offset and AGC enabled */
+	{ TVP5150_MISC_CTL         , 0x69 },	/* Activate YCrCb output 0x9 or 0xd ? */
+	{ TVP5150_AUTOSW_MSK       , 0x00 },	/* Activates video std autodetection for all standards */
+	{ TVP5150_DATA_RATE_SEL    , 0x07 },	/* Default format: 0x47. For 4:2:2: 0x40 */
+	{ TVP5150_CHROMA_PROC_CTL_1, 0x0c },
+	{ TVP5150_CHROMA_PROC_CTL_2, 0x54 },
+	{ 0x27                     , 0x20 },	/* Non documented, but initialized on WinTV USB2 */
+	{ 0xff,0xff }
+};
+
+struct tvp5150_vbi_type {
+	unsigned int vbi_type;
+	unsigned int ini_line;
+	unsigned int end_line;
+	unsigned int by_field :1;
+};
+
+struct i2c_vbi_ram_value {
+	u16                     reg;
+	struct tvp5150_vbi_type type;
+	unsigned char           values[16];
+};
+
+/* This struct have the values for each supported VBI Standard
+ * by
+ tvp5150_vbi_types should follow the same order as vbi_ram_default
+ * value 0 means rom position 0x10, value 1 means rom position 0x30
+ * and so on. There are 16 possible locations from 0 to 15.
+ */
+
+static struct i2c_vbi_ram_value vbi_ram_default[] =
+{
+	/* FIXME: Current api doesn't handle all VBI types, those not
+	   yet supported are placed under #if 0 */
+#if 0
+	{0x010, /* Teletext, SECAM, WST System A */
+		{V4L2_SLICED_TELETEXT_SECAM,6,23,1},
+		{ 0xaa, 0xaa, 0xff, 0xff, 0xe7, 0x2e, 0x20, 0x26,
+		  0xe6, 0xb4, 0x0e, 0x00, 0x00, 0x00, 0x10, 0x00 }
+	},
+#endif
+	{0x030, /* Teletext, PAL, WST System B */
+		{V4L2_SLICED_TELETEXT_B,6,22,1},
+		{ 0xaa, 0xaa, 0xff, 0xff, 0x27, 0x2e, 0x20, 0x2b,
+		  0xa6, 0x72, 0x10, 0x00, 0x00, 0x00, 0x10, 0x00 }
+	},
+#if 0
+	{0x050, /* Teletext, PAL, WST System C */
+		{V4L2_SLICED_TELETEXT_PAL_C,6,22,1},
+		{ 0xaa, 0xaa, 0xff, 0xff, 0xe7, 0x2e, 0x20, 0x22,
+		  0xa6, 0x98, 0x0d, 0x00, 0x00, 0x00, 0x10, 0x00 }
+	},
+	{0x070, /* Teletext, NTSC, WST System B */
+		{V4L2_SLICED_TELETEXT_NTSC_B,10,21,1},
+		{ 0xaa, 0xaa, 0xff, 0xff, 0x27, 0x2e, 0x20, 0x23,
+		  0x69, 0x93, 0x0d, 0x00, 0x00, 0x00, 0x10, 0x00 }
+	},
+	{0x090, /* Tetetext, NTSC NABTS System C */
+		{V4L2_SLICED_TELETEXT_NTSC_C,10,21,1},
+		{ 0xaa, 0xaa, 0xff, 0xff, 0xe7, 0x2e, 0x20, 0x22,
+		  0x69, 0x93, 0x0d, 0x00, 0x00, 0x00, 0x15, 0x00 }
+	},
+	{0x0b0, /* Teletext, NTSC-J, NABTS System D */
+		{V4L2_SLICED_TELETEXT_NTSC_D,10,21,1},
+		{ 0xaa, 0xaa, 0xff, 0xff, 0xa7, 0x2e, 0x20, 0x23,
+		  0x69, 0x93, 0x0d, 0x00, 0x00, 0x00, 0x10, 0x00 }
+	},
+	{0x0d0, /* Closed Caption, PAL/SECAM */
+		{V4L2_SLICED_CAPTION_625,22,22,1},
+		{ 0xaa, 0x2a, 0xff, 0x3f, 0x04, 0x51, 0x6e, 0x02,
+		  0xa6, 0x7b, 0x09, 0x00, 0x00, 0x00, 0x27, 0x00 }
+	},
+#endif
+	{0x0f0, /* Closed Caption, NTSC */
+		{V4L2_SLICED_CAPTION_525,21,21,1},
+		{ 0xaa, 0x2a, 0xff, 0x3f, 0x04, 0x51, 0x6e, 0x02,
+		  0x69, 0x8c, 0x09, 0x00, 0x00, 0x00, 0x27, 0x00 }
+	},
+	{0x110, /* Wide Screen Signal, PAL/SECAM */
+		{V4L2_SLICED_WSS_625,23,23,1},
+		{ 0x5b, 0x55, 0xc5, 0xff, 0x00, 0x71, 0x6e, 0x42,
+		  0xa6, 0xcd, 0x0f, 0x00, 0x00, 0x00, 0x3a, 0x00 }
+	},
+#if 0
+	{0x130, /* Wide Screen Signal, NTSC C */
+		{V4L2_SLICED_WSS_525,20,20,1},
+		{ 0x38, 0x00, 0x3f, 0x00, 0x00, 0x71, 0x6e, 0x43,
+		  0x69, 0x7c, 0x08, 0x00, 0x00, 0x00, 0x39, 0x00 }
+	},
+	{0x150, /* Vertical Interval Timecode (VITC), PAL/SECAM */
+		{V4l2_SLICED_VITC_625,6,22,0},
+		{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f, 0x6d, 0x49,
+		  0xa6, 0x85, 0x08, 0x00, 0x00, 0x00, 0x4c, 0x00 }
+	},
+	{0x170, /* Vertical Interval Timecode (VITC), NTSC */
+		{V4l2_SLICED_VITC_525,10,20,0},
+		{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f, 0x6d, 0x49,
+		  0x69, 0x94, 0x08, 0x00, 0x00, 0x00, 0x4c, 0x00 }
+	},
+#endif
+	{0x190, /* Video Program System (VPS), PAL */
+		{V4L2_SLICED_VPS,16,16,0},
+		{ 0xaa, 0xaa, 0xff, 0xff, 0xba, 0xce, 0x2b, 0x0d,
+		  0xa6, 0xda, 0x0b, 0x00, 0x00, 0x00, 0x60, 0x00 }
+	},
+	/* 0x1d0 User programmable */
+
+	/* End of struct */
+	{ (u16)-1 }
+};
+
+static int tvp5150_write_inittab(struct i2c_client *c,
+                                 const struct i2c_reg_value *regs)
+{
+	while (regs->reg != 0xff) {
+		tvp5150_write(c, regs->reg, regs->value);
+		regs++;
+	}
+	return 0;
+}
+
+static int tvp5150_vdp_init(struct i2c_client *c,
+                            const struct i2c_vbi_ram_value *regs)
+{
+	unsigned int i;
+
+	/* Disable Full Field */
+	tvp5150_write(c, TVP5150_FULL_FIELD_ENA, 0);
+
+	/* Before programming, Line mode should be at 0xff */
+	for (i = TVP5150_LINE_MODE_INI; i <= TVP5150_LINE_MODE_END; i++)
+		tvp5150_write(c, i, 0xff);
+
+	/* Load Ram Table */
+	while (regs->reg != (u16)-1) {
+		tvp5150_write(c, TVP5150_CONF_RAM_ADDR_HIGH, regs->reg >> 8);
+		tvp5150_write(c, TVP5150_CONF_RAM_ADDR_LOW, regs->reg);
+
+		for (i = 0; i < 16; i++)
+			tvp5150_write(c, TVP5150_VDP_CONF_RAM_DATA, regs->values[i]);
+
+		regs++;
+	}
+	return 0;
+}
+
+static int tvp5150_set_std(struct tvp5150 *core, v4l2_std_id std)
+{
+	struct i2c_client *c = core->sen.i2c_client;
+	int                fmt = 0;
+
+	/* First tests should be against specific std */
+	if (std == V4L2_STD_ALL) {
+		fmt = VIDEO_STD_AUTO_SWITCH_BIT;	/* Autodetect mode */
+	} else if (std & V4L2_STD_NTSC_443) {
+		fmt = VIDEO_STD_NTSC_4_43_BIT;
+	} else if (std & V4L2_STD_PAL_M) {
+		fmt = VIDEO_STD_PAL_M_BIT;
+	} else if (std & (V4L2_STD_PAL_N | V4L2_STD_PAL_Nc)) {
+		fmt = VIDEO_STD_PAL_COMBINATION_N_BIT;
+	} else {
+		/* Then, test against generic ones */
+		if (std & V4L2_STD_NTSC)
+			fmt = VIDEO_STD_NTSC_MJ_BIT;
+		else if (std & V4L2_STD_PAL)
+			fmt = VIDEO_STD_PAL_BDGHIN_BIT;
+		else if (std & V4L2_STD_SECAM)
+			fmt = VIDEO_STD_SECAM_BIT;
+	}
+	DBG_PRINT("Set video std register to %d.\n", fmt);
+	tvp5150_write(c, TVP5150_VIDEO_STD, fmt);
+
+	return 0;
+}
+
+static int tvp5150_reset(struct tvp5150 *core)
+{
+	struct i2c_client *c = core->sen.i2c_client;
+
+	/* Initializes TVP5150 to its default values */
+	tvp5150_write_inittab(c, tvp5150_init_default);
+
+	/* Initializes VDP registers */
+	tvp5150_vdp_init(c, vbi_ram_default);
+
+	/* Selects decoder input */
+	tvp5150_selmux(core);
+
+	/* Initializes TVP5150 to stream enabled values */
+	tvp5150_write_inittab(c, tvp5150_init_enable);
+
+//	/* Initialize image preferences */
+//	v4l2_ctrl_handler_setup(&decoder->hdl);
+
+//	tvp5150_set_std(core, video_fmts[core->video_idx].v4l2_id);
+	tvp5150_set_std(core, V4L2_STD_ALL);
+	return 0;
+};
+
+/***********************************************************************
+ * mxc_v4l2_capture interface.
+ ***********************************************************************/
+
+/*!
+ * Return attributes of current video standard.
+ * Since this device autodetects the current standard, this function also
+ * sets the values that need to be changed if the standard changes.
+ * There is no set std equivalent function.
+ *
+ *  @return		V4L2 Standard ID.
+ */
+static v4l2_std_id tvp5150_get_std(struct tvp5150 *core)
+{
+	int val = tvp5150_read(core->sen.i2c_client, TVP5150_STATUS_REG_5);
+	int idx;
+//DBG_PRINT("Status Reg #5 %02X\n", val);
+
+	switch (val & 0x0F) {
+	case 0x1: idx = TVP5150_NTSC      ; break;
+	case 0x3: idx = TVP5150_PAL       ; break;
+	case 0x5: idx = TVP5150_PAL_M     ; break;
+	case 0x7: idx = TVP5150_PAL_N     ; break;
+	case 0x9: idx = TVP5150_NTSC_443  ; break;
+	case 0xB: idx = TVP5150_SECAM     ; break;
+	default : idx = TVP5150_NOT_LOCKED; break;
+	}
+	core->video_idx = idx;
+	core->sen.streamcap.timeperframe.denominator = video_fmts[idx].frame_rate;
+	core->sen.streamcap.timeperframe.numerator   = 1;
+	core->sen.pix.width  = video_fmts[idx].raw_width ;
+	core->sen.pix.height = video_fmts[idx].raw_height;
+	core->sen.pix.pixelformat = V4L2_PIX_FMT_UYVY;
+	core->sen.pix.priv        = 1;  /* 1 is used to indicate TV in */
+	//core->sen.on = true;
+
+	return video_fmts[idx].v4l2_id;
+}
+
+/***********************************************************************
+ * IOCTL Functions from v4l2_int_ioctl_desc.
+ ***********************************************************************/
+
+/*!
+ * ioctl_g_ifparm - V4L2 sensor interface handler for vidioc_int_g_ifparm_num
+ * s: pointer to standard V4L2 device structure
+ * p: pointer to standard V4L2 vidioc_int_g_ifparm_num ioctl structure
+ *
+ * Gets slave interface parameters.
+ * Calculates the required xclk value to support the requested
+ * clock parameters in p.  This value is returned in the p
+ * parameter.
+ *
+ * vidioc_int_g_ifparm returns platform-specific information about the
+ * interface settings used by the sensor.
+ *
+ * Called on open.
+ */
+static int ioctl_g_ifparm(struct v4l2_int_device *s, struct v4l2_ifparm *p)
+{
+	DBG_PRINT("TVP5150:ioctl_g_ifparm\n");
+
+	if (s == NULL) {
+		pr_err("TVP5150:ERROR!! no slave device set!\n");
+		return -1;
+	}
+
+	/* Initialize structure to 0s then set any non-0 values. */
+	memset(p, 0, sizeof(*p));
+	p->if_type = V4L2_IF_TYPE_BT656; /* This is the only possibility. */
+	p->u.bt656.mode            = V4L2_IF_TYPE_BT656_MODE_NOBT_8BIT;
+	p->u.bt656.nobt_hs_inv     = 1;
+	p->u.bt656.bt_sync_correct = 0;
+
+	// TVP5150 has a dedicated clock so no clock settings needed.
+
+	return 0;
+}
+
+/*!
+ * Sets the camera power.
+ *
+ * s  pointer to the camera device
+ * on if 1, power is to be turned on.  0 means power is to be turned off
+ *
+ * ioctl_s_power - V4L2 sensor interface handler for vidioc_int_s_power_num
+ * @s: pointer to standard V4L2 device structure
+ * @on: power state to which device is to be set
+ *
+ * Sets devices power state to requrested state, if possible.
+ * This is called on open, close, suspend and resume.
+ */
+static int ioctl_s_power(struct v4l2_int_device *s, int on)
+{
+	struct tvp5150 *core = s->priv;
+
+  DBG_PRINT("On %d\n", on);
+
+  if (on) {
+		//scrivere 1 in Operation mode control TODO
+    //gpio_sensor_poweron(); TODO
+  } else {
+    //gpio_sensor_poweroff(); TODO
+  }
+  core->sen.on = on;
+  return 0;
+}
+
+/*!
+ * ioctl_g_parm - V4L2 sensor interface handler for VIDIOC_G_PARM ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @a: pointer to standard V4L2 VIDIOC_G_PARM ioctl structure
+ *
+ * Returns the sensor's video CAPTURE parameters.
+ */
+static int ioctl_g_parm(struct v4l2_int_device *s, struct v4l2_streamparm *a)
+{
+	struct tvp5150          *core  = s->priv;
+	struct v4l2_captureparm *cparm = &a->parm.capture;
+
+DBG_PRINT("TVP5150:ioctl_g_parm\n");
+	dev_dbg(&core->sen.i2c_client->dev, "tvp5150:ioctl_g_parm\n");
+
+	switch (a->type) {
+	/* These are all the possible cases. */
+	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
+		pr_debug("   type is V4L2_BUF_TYPE_VIDEO_CAPTURE\n");
+		memset(a, 0, sizeof(*a));
+		a->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+		cparm->capability   = core->sen.streamcap.capability;
+		cparm->timeperframe = core->sen.streamcap.timeperframe;
+		cparm->capturemode  = core->sen.streamcap.capturemode;
+		break;
+
+	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
+	case V4L2_BUF_TYPE_VIDEO_OVERLAY:
+	case V4L2_BUF_TYPE_VBI_CAPTURE:
+	case V4L2_BUF_TYPE_VBI_OUTPUT:
+	case V4L2_BUF_TYPE_SLICED_VBI_CAPTURE:
+	case V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:
+		break;
+
+	default:
+		pr_debug("ioctl_g_parm:type is unknown %d\n", a->type);
+		break;
+	}
+
+	return 0;
+}
+
+/*!
+ * ioctl_s_parm - V4L2 sensor interface handler for VIDIOC_S_PARM ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @a: pointer to standard V4L2 VIDIOC_S_PARM ioctl structure
+ *
+ * Configures the sensor to use the input parameters, if possible.  If
+ * not possible, reverts to the old parameters and returns the
+ * appropriate error code.
+ *
+ * This driver cannot change these settings.
+ */
+static int ioctl_s_parm(struct v4l2_int_device *s, struct v4l2_streamparm *a)
+{
+	struct tvp5150 *core = s->priv;
+
+DBG_PRINT("TVP5150:ioctl_s_parm\n");
+	dev_dbg(&core->sen.i2c_client->dev, "tvp5150:ioctl_s_parm\n");
+
+	switch (a->type) {
+	/* These are all the possible cases. */
+	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
+	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
+	case V4L2_BUF_TYPE_VIDEO_OVERLAY:
+	case V4L2_BUF_TYPE_VBI_CAPTURE:
+	case V4L2_BUF_TYPE_VBI_OUTPUT:
+	case V4L2_BUF_TYPE_SLICED_VBI_CAPTURE:
+	case V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:
+		break;
+
+	default:
+		pr_debug("   type is unknown - %d\n", a->type);
+		break;
+	}
+
+	return 0;
+}
+
+/*!
+ * ioctl_g_fmt_cap - V4L2 sensor interface handler for ioctl_g_fmt_cap
+ * @s: pointer to standard V4L2 device structure
+ * @f: pointer to standard V4L2 v4l2_format structure
+ *
+ * Returns the sensor's current pixel format in the v4l2_format
+ * parameter.
+ */
+static int ioctl_g_fmt_cap(struct v4l2_int_device *s, struct v4l2_format *f)
+{
+	struct tvp5150 *core = s->priv;
+//	DBG_PRINT("\n");
+	dev_dbg(&core->sen.i2c_client->dev, "tvp5150:ioctl_g_fmt_cap\n");
+
+	switch (f->type) {
+	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
+		memcpy(&f->fmt.pix, &core->sen.pix, sizeof(struct v4l2_pix_format));;
+		DBG_PRINT("Returning size of %dx%d\n", f->fmt.pix.width, f->fmt.pix.height);
+		break;
+
+	case V4L2_BUF_TYPE_PRIVATE:
+		f->fmt.pix.pixelformat = tvp5150_get_std(core);
+#ifdef DEBUG
+		static unsigned long oldstd;
+		if(oldstd!=f->fmt.pix.pixelformat){
+			char* stdname;
+			unsigned char vb_start;
+			unsigned char vb_stop;
+			switch(f->fmt.pix.pixelformat){
+			case V4L2_STD_PAL : stdname = "V4L2_STD_PAL" ; break;
+			case V4L2_STD_NTSC: stdname = "V4L2_STD_NTSC"; break;
+			default           : stdname = "UNKNOWN"      ; break;
+			}
+			DBG_PRINT("std changed to %s\n", stdname);
+			oldstd = f->fmt.pix.pixelformat;
+		}
+#endif
+		break;
+
+	default:
+		//f->fmt.pix = core->sen.pix;
+		memcpy(&f->fmt.pix, &core->sen.pix, sizeof(struct v4l2_pix_format));;
+		break;
+	}
+
+	return 0;
+}
+
+/*!
+ * ioctl_queryctrl - V4L2 sensor interface handler for VIDIOC_QUERYCTRL ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @qc: standard V4L2 VIDIOC_QUERYCTRL ioctl structure
+ *
+ * If the requested control is supported, returns the control information
+ * from the video_control[] array.  Otherwise, returns -EINVAL if the
+ * control is not supported.
+ */
+static int ioctl_queryctrl(struct v4l2_int_device *s,
+                           struct v4l2_queryctrl *qc)
+{
+	struct tvp5150 *core = s->priv;
+	int i;
+
+DBG_PRINT("TVP5150:ioctl_queryctrl\n");
+	dev_dbg(&core->sen.i2c_client->dev, "tvp5150:ioctl_queryctrl\n");
+	for (i = 0; i < ARRAY_SIZE(tvp5150_qctrl); i++) {
+		if (qc->id && qc->id == tvp5150_qctrl[i].id) {
+			memcpy(qc, &(tvp5150_qctrl[i]), sizeof(*qc));
+			return 0;
+		}
+	}
+	return -EINVAL;
+}
+
+/*!
+ * ioctl_g_ctrl - V4L2 sensor interface handler for VIDIOC_G_CTRL ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @vc: standard V4L2 VIDIOC_G_CTRL ioctl structure
+ *
+ * If the requested control is supported, returns the control's current
+ * value from the video_control[] array.  Otherwise, returns -EINVAL
+ * if the control is not supported.
+ */
+static int ioctl_g_ctrl(struct v4l2_int_device *s, struct v4l2_control *vc)
+{
+	struct tvp5150 *core = s->priv;
+	int ret = 0;
+
+DBG_PRINT("TVP5150:ioctl_g_ctrl:id %d\n", vc->id);
+	dev_dbg(&core->sen.i2c_client->dev, "tvp5150:ioctl_g_ctrl\n");
+
+	switch (vc->id) {
+	case V4L2_CID_BRIGHTNESS:
+		dev_dbg(&core->sen.i2c_client->dev, "   V4L2_CID_BRIGHTNESS\n");
+		core->sen.brightness = tvp5150_read(core->sen.i2c_client, TVP5150_BRIGHT_CTL);
+		vc->value = core->sen.brightness;
+		break;
+	case V4L2_CID_CONTRAST:
+		dev_dbg(&core->sen.i2c_client->dev, "   V4L2_CID_CONTRAST\n");
+		vc->value = core->sen.contrast;
+		break;
+	case V4L2_CID_SATURATION:
+		dev_dbg(&core->sen.i2c_client->dev, "   V4L2_CID_SATURATION\n");
+		core->sen.saturation = tvp5150_read(core->sen.i2c_client, TVP5150_SATURATION_CTL);
+		vc->value = core->sen.saturation;
+		break;
+	case V4L2_CID_HUE:
+		dev_dbg(&core->sen.i2c_client->dev, "   V4L2_CID_HUE\n");
+		vc->value = core->sen.hue;
+		break;
+	case V4L2_CID_AUTO_WHITE_BALANCE:
+		dev_dbg(&core->sen.i2c_client->dev, "   V4L2_CID_AUTO_WHITE_BALANCE\n");
+		break;
+	case V4L2_CID_DO_WHITE_BALANCE:
+		dev_dbg(&core->sen.i2c_client->dev, "   V4L2_CID_DO_WHITE_BALANCE\n");
+		break;
+	case V4L2_CID_RED_BALANCE:
+		dev_dbg(&core->sen.i2c_client->dev, "   V4L2_CID_RED_BALANCE\n");
+		vc->value = core->sen.red;
+		break;
+	case V4L2_CID_BLUE_BALANCE:
+		dev_dbg(&core->sen.i2c_client->dev, "   V4L2_CID_BLUE_BALANCE\n");
+		vc->value = core->sen.blue;
+		break;
+	case V4L2_CID_GAMMA:
+		dev_dbg(&core->sen.i2c_client->dev, "   V4L2_CID_GAMMA\n");
+		break;
+	case V4L2_CID_EXPOSURE:
+		dev_dbg(&core->sen.i2c_client->dev, "   V4L2_CID_EXPOSURE\n");
+		vc->value = core->sen.ae_mode;
+		break;
+	case V4L2_CID_AUTOGAIN:
+		dev_dbg(&core->sen.i2c_client->dev, "   V4L2_CID_AUTOGAIN\n");
+		break;
+	case V4L2_CID_GAIN:
+		dev_dbg(&core->sen.i2c_client->dev, "   V4L2_CID_GAIN\n");
+		break;
+	case V4L2_CID_HFLIP:
+		dev_dbg(&core->sen.i2c_client->dev, "   V4L2_CID_HFLIP\n");
+		break;
+	case V4L2_CID_VFLIP:
+		dev_dbg(&core->sen.i2c_client->dev, "   V4L2_CID_VFLIP\n");
+		break;
+	default:
+		dev_dbg(&core->sen.i2c_client->dev, "   Default case\n");
+		vc->value = 0;
+		ret = -EPERM;
+		break;
+	}
+	return ret;
+}
+
+/*!
+ * ioctl_s_ctrl - V4L2 sensor interface handler for VIDIOC_S_CTRL ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @vc: standard V4L2 VIDIOC_S_CTRL ioctl structure
+ *
+ * If the requested control is supported, sets the control's current
+ * value in HW (and updates the video_control[] array).  Otherwise,
+ * returns -EINVAL if the control is not supported.
+ */
+static int ioctl_s_ctrl(struct v4l2_int_device *s, struct v4l2_control *vc)
+{
+	struct tvp5150 *core = s->priv;
+	int retval = 0;
+	u8 tmp;
+
+DBG_PRINT("TVP5150:ioctl_s_ctrl:id %d\n", vc->id);
+	dev_dbg(&core->sen.i2c_client->dev, "tvp5150:ioctl_s_ctrl\n");
+
+	switch (vc->id) {
+	case V4L2_CID_BRIGHTNESS:
+		dev_dbg(&core->sen.i2c_client->dev, "   V4L2_CID_BRIGHTNESS\n");
+		tmp = vc->value;
+		tvp5150_write(core->sen.i2c_client, TVP5150_BRIGHT_CTL, tmp);
+		core->sen.brightness = vc->value;
+		break;
+	case V4L2_CID_CONTRAST:
+		dev_dbg(&core->sen.i2c_client->dev, "   V4L2_CID_CONTRAST\n");
+		break;
+	case V4L2_CID_SATURATION:
+		dev_dbg(&core->sen.i2c_client->dev, "   V4L2_CID_SATURATION\n");
+		tmp = vc->value;
+		tvp5150_write(core->sen.i2c_client, TVP5150_SATURATION_CTL, tmp);
+		core->sen.saturation = vc->value;
+		break;
+	case V4L2_CID_HUE:
+		dev_dbg(&core->sen.i2c_client->dev, "   V4L2_CID_HUE\n");
+		break;
+	case V4L2_CID_AUTO_WHITE_BALANCE:
+		dev_dbg(&core->sen.i2c_client->dev, "   V4L2_CID_AUTO_WHITE_BALANCE\n");
+		break;
+	case V4L2_CID_DO_WHITE_BALANCE:
+		dev_dbg(&core->sen.i2c_client->dev, "   V4L2_CID_DO_WHITE_BALANCE\n");
+		break;
+	case V4L2_CID_RED_BALANCE:
+		dev_dbg(&core->sen.i2c_client->dev, "   V4L2_CID_RED_BALANCE\n");
+		break;
+	case V4L2_CID_BLUE_BALANCE:
+		dev_dbg(&core->sen.i2c_client->dev, "   V4L2_CID_BLUE_BALANCE\n");
+		break;
+	case V4L2_CID_GAMMA:
+		dev_dbg(&core->sen.i2c_client->dev, "   V4L2_CID_GAMMA\n");
+		break;
+	case V4L2_CID_EXPOSURE:
+		dev_dbg(&core->sen.i2c_client->dev, "   V4L2_CID_EXPOSURE\n");
+		break;
+	case V4L2_CID_AUTOGAIN:
+		dev_dbg(&core->sen.i2c_client->dev, "   V4L2_CID_AUTOGAIN\n");
+		break;
+	case V4L2_CID_GAIN:
+		dev_dbg(&core->sen.i2c_client->dev, "   V4L2_CID_GAIN\n");
+		break;
+	case V4L2_CID_HFLIP:
+		dev_dbg(&core->sen.i2c_client->dev, "   V4L2_CID_HFLIP\n");
+		break;
+	case V4L2_CID_VFLIP:
+		dev_dbg(&core->sen.i2c_client->dev, "   V4L2_CID_VFLIP\n");
+		break;
+	default:
+		dev_dbg(&core->sen.i2c_client->dev, "   Default case\n");
+		retval = -EPERM;
+		break;
+	}
+	return retval;
+}
+
+/*!
+ * ioctl_enum_framesizes - V4L2 sensor interface handler for
+ *			   VIDIOC_ENUM_FRAMESIZES ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @fsize: standard V4L2 VIDIOC_ENUM_FRAMESIZES ioctl structure
+ *
+ * Return 0 if successful, otherwise -EINVAL.
+ */
+static int ioctl_enum_framesizes(struct v4l2_int_device *s,
+                                 struct v4l2_frmsizeenum *fsize)
+{
+	struct tvp5150 *core = s->priv;
+
+	if (fsize->index >= 1)
+		return -EINVAL;
+
+	fsize->discrete.width  = video_fmts[core->video_idx].active_width;
+	fsize->discrete.height = video_fmts[core->video_idx].active_height;
+DBG_PRINT("return %d x %d\n", fsize->discrete.width, fsize->discrete.height);
+
+	return 0;
+}
+
+/*!
+ * ioctl_enum_frameintervals - V4L2 sensor interface handler for
+ *			       VIDIOC_ENUM_FRAMEINTERVALS ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @fival: standard V4L2 VIDIOC_ENUM_FRAMEINTERVALS ioctl structure
+ *
+ * Return 0 if successful, otherwise -EINVAL.
+ */
+static int ioctl_enum_frameintervals(struct v4l2_int_device *s,
+                                     struct v4l2_frmivalenum *fival)
+{
+	int i;
+DBG_PRINT("index %d, width %d, height %d\n", fival->index, fival->width, fival->height);
+	if (fival->index != 0)
+		return -EINVAL;
+
+	for (i=0; i<ARRAY_SIZE(video_fmts)-1; i++) {
+		if ((fival->width  == video_fmts[i].active_width ) &&
+		    (fival->height == video_fmts[i].active_height) ){
+			fival->type = V4L2_FRMIVAL_TYPE_DISCRETE;
+			fival->discrete.denominator = video_fmts[i].frame_rate;
+			fival->discrete.numerator   = 1;
+			return 0;
+		}
+	}
+
+	return -EINVAL;
+
+}
+
+/*!
+ * ioctl_g_chip_ident - V4L2 sensor interface handler for
+ *			VIDIOC_DBG_G_CHIP_IDENT ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @id: pointer to int
+ *
+ * Return 0.
+ */
+static int ioctl_g_chip_ident(struct v4l2_int_device *s, int *id)
+{
+	((struct v4l2_dbg_chip_ident *)id)->match.type =
+					V4L2_CHIP_MATCH_I2C_DRIVER;
+	strcpy(((struct v4l2_dbg_chip_ident *)id)->match.name,
+						"tvp5150_decoder");
+	((struct v4l2_dbg_chip_ident *)id)->ident = V4L2_IDENT_TVP5150;
+
+	return 0;
+}
+
+/*!
+ * ioctl_init - V4L2 sensor interface handler for VIDIOC_INT_INIT
+ * @s: pointer to standard V4L2 device structure
+ */
+static int ioctl_init(struct v4l2_int_device *s)
+{
+	DBG_PRINT("\n");
+	return 0;
+}
+
+/*!
+ * ioctl_dev_init - V4L2 sensor interface handler for vidioc_int_dev_init_num
+ * @s: pointer to standard V4L2 device structure
+ *
+ * Initialise the device when slave attaches to the master.
+ */
+static int ioctl_dev_init(struct v4l2_int_device *s)
+{
+	struct tvp5150 *core = s->priv;
+DBG_PRINT("\n");
+	dev_dbg(&core->sen.i2c_client->dev, "tvp5150:ioctl_dev_init\n");
+	return 0;
+}
+
+/*!
+ * This structure defines all the ioctls for this module.
+ */
+static struct v4l2_int_ioctl_desc tvp5150_ioctl_desc[] = {
+
+	{vidioc_int_dev_init_num           , (v4l2_int_ioctl_func*)ioctl_dev_init},
+	//{vidioc_int_dev_exit_num           , (v4l2_int_ioctl_func*)ioctl_dev_exit},
+	{vidioc_int_s_power_num            , (v4l2_int_ioctl_func*)ioctl_s_power},
+	{vidioc_int_g_ifparm_num           , (v4l2_int_ioctl_func*)ioctl_g_ifparm},
+	//{vidioc_int_g_needs_reset_num      , (v4l2_int_ioctl_func*)ioctl_g_needs_reset},
+	//{vidioc_int_reset_num              , (v4l2_int_ioctl_func *)ioctl_reset},
+	{vidioc_int_init_num               , (v4l2_int_ioctl_func*)ioctl_init},
+	//{vidioc_int_enum_fmt_cap_num       , (v4l2_int_ioctl_func*)ioctl_enum_fmt_cap},
+	//{vidioc_int_try_fmt_cap_num        , (v4l2_int_ioctl_func*)ioctl_try_fmt_cap},
+	{vidioc_int_g_fmt_cap_num          , (v4l2_int_ioctl_func*)ioctl_g_fmt_cap},
+	//{vidioc_int_s_fmt_cap_num          , (v4l2_int_ioctl_func*)ioctl_s_fmt_cap},
+	{vidioc_int_g_parm_num             , (v4l2_int_ioctl_func*)ioctl_g_parm},
+	{vidioc_int_s_parm_num             , (v4l2_int_ioctl_func*)ioctl_s_parm},
+	{vidioc_int_queryctrl_num          , (v4l2_int_ioctl_func*)ioctl_queryctrl},
+	{vidioc_int_g_ctrl_num             , (v4l2_int_ioctl_func*)ioctl_g_ctrl},
+	{vidioc_int_s_ctrl_num             , (v4l2_int_ioctl_func*)ioctl_s_ctrl},
+	{vidioc_int_enum_framesizes_num    , (v4l2_int_ioctl_func*)ioctl_enum_framesizes},
+	{vidioc_int_enum_frameintervals_num, (v4l2_int_ioctl_func*)ioctl_enum_frameintervals},
+	{vidioc_int_g_chip_ident_num       , (v4l2_int_ioctl_func*)ioctl_g_chip_ident},
+};
+
+/*!
+ * TVP5150 probe.
+ *
+ * @return Error code indicating success or failure.
+ */
+static int tvp5150_probe(struct i2c_client *c,
+                         const struct i2c_device_id *id)
+{
+	struct tvp5150     *core;
+	int                 tvp5150_id[4];
+	int                 i;
+	int                 res;
+	int                 ret;
+	struct device      *dev = &c->dev;
+	struct regmap      *gpr;
+
+	DBG_PRINT("TVP5150:probe:\n");
+
+	/* Check if the adapter supports the needed features */
+	if (!i2c_check_functionality(c->adapter,
+	     I2C_FUNC_SMBUS_READ_BYTE | I2C_FUNC_SMBUS_WRITE_BYTE_DATA))
+		return -EIO;
+
+	core = kzalloc(sizeof(struct tvp5150), GFP_KERNEL);
+	if (!core) {
+		return -ENOMEM;
+	}
+
+	core->video_idx = TVP5150_PAL; //TODO deve tornare l'attuale
+
+	core->sen.i2c_client = c;
+	core->sen.streamcap.timeperframe.denominator = video_fmts[core->video_idx].frame_rate;
+	core->sen.streamcap.timeperframe.numerator   = 1;
+	core->sen.pix.width       = video_fmts[core->video_idx].raw_width;
+	core->sen.pix.height      = video_fmts[core->video_idx].raw_height;
+	core->sen.pix.pixelformat = V4L2_PIX_FMT_UYVY;  /* YUV422 */
+	core->sen.pix.priv        = 1;  /* 1 is used to indicate TV in */
+	core->sen.on = true;
+
+	core->sen.sensor_clk = devm_clk_get(dev, "csi_mclk");
+	if (IS_ERR(core->sen.sensor_clk)) {
+		dev_err(dev, "get mclk failed\n");
+		return PTR_ERR(core->sen.sensor_clk);
+	}
+
+	ret = of_property_read_u32(dev->of_node, "mclk", &core->sen.mclk);
+	if (ret) {
+		DBG_PRINT("TVP5150:probe:mclk frequency is invalid\n");
+		dev_err(dev, "mclk frequency is invalid\n");
+		return ret;
+	}
+
+	ret = of_property_read_u32(dev->of_node, "mclk_source", (u32*)&(core->sen.mclk_source));
+	if (ret) {
+		DBG_PRINT("TVP5150:probe:mclk_source is invalid\n");
+		dev_err(dev, "mclk_source invalid\n");
+		return ret;
+	}
+
+	ret = of_property_read_u32(dev->of_node, "csi_id", &core->sen.csi);
+	if (ret) {
+		DBG_PRINT("TVP5150:probe:csi_id is invalid\n");
+		dev_err(dev, "csi_id invalid\n");
+		return ret;
+	}
+
+	gpr = syscon_regmap_lookup_by_compatible("fsl,imx6q-iomuxc-gpr");
+	if (!IS_ERR(gpr)) {
+		if (of_machine_is_compatible("fsl,imx6q")) {
+			int mask = core->sen.csi ? (1 << 20) : (1 << 19);
+
+			regmap_update_bits(gpr, IOMUXC_GPR1, mask, mask);
+		} else if (of_machine_is_compatible("fsl,imx6dl")) {
+			int mask = core->sen.csi ? (7 << 3) : (7 << 0);
+			int val =  core->sen.csi ? (4 << 3) : (4 << 0);
+
+			regmap_update_bits(gpr, IOMUXC_GPR13, mask, val);
+		}
+	} else {
+		pr_err("%s: failed to find fsl,imx6q-iomux-gpr regmap\n",
+		       __func__);
+	}
+
+	clk_prepare_enable(core->sen.sensor_clk);
+
+	/*
+	 * Read consequent registers - TVP5150_MSB_DEV_ID, TVP5150_LSB_DEV_ID,
+	 * TVP5150_ROM_MAJOR_VER, TVP5150_ROM_MINOR_VER
+	 */
+	for (i = 0; i < 4; i++) {
+		res = tvp5150_read(c, TVP5150_MSB_DEV_ID + i);
+		if (res < 0)
+			goto free_core;
+		tvp5150_id[i] = res;
+	}
+	DBG_PRINT("chip found @ 0x%02x (%s)\n",
+	        c->addr << 1, c->adapter->name);
+	if (tvp5150_id[2] == 4 && tvp5150_id[3] == 0) { /* Is TVP5150AM1 */
+		DBG_PRINT("tvp%02x%02xam1 detected.\n",
+		        tvp5150_id[0], tvp5150_id[1]);
+		/* ITU-T BT.656.4 timing */
+		tvp5150_write(c, TVP5150_REV_SELECT, 0);
+	} else {
+		/* Is TVP5150A */
+		if (tvp5150_id[2] == 3 || tvp5150_id[3] == 0x21) {
+			DBG_PRINT("tvp%02x%02xa detected.\n",
+			        tvp5150_id[2], tvp5150_id[3]);
+		} else {
+			DBG_PRINT("*** unknown tvp%02x%02x chip detected.\n",
+			        tvp5150_id[2], tvp5150_id[3]);
+			DBG_PRINT("*** Rom ver is %d.%d\n",
+			        tvp5150_id[2], tvp5150_id[3]);
+		}
+	}
+
+	tvp5150_reset(core);
+
+	DBG_PRINT("set core variables\n");
+	core->input  = TVP5150_COMPOSITE1;
+	core->enable = 1;
+
+	tvp5150_get_std(core);
+#ifdef TVP5150_DBG
+	tvp5150_log_status(c);
+#endif
+
+	/* This function attaches this structure to the /dev/videox device.
+	 * The pointer in priv points to the tvp5150 structure here.*/
+	        core->int_dev.priv   = core;
+	        core->int_dev.module = THIS_MODULE;
+	sprintf(core->int_dev.name   , "tvp5150-%d", core->sen.csi);
+	        core->int_dev.type   = v4l2_int_type_slave;
+
+	        core->slave.ioctls     = tvp5150_ioctl_desc;
+	        core->slave.num_ioctls = ARRAY_SIZE(tvp5150_ioctl_desc);
+	sprintf(core->slave.attach_to  , "mxc_v4l2_cap%d", core->sen.csi);
+	        core->int_dev.u	.slave = &core->slave;
+
+	DBG_PRINT("int_dev name '%s', attach_to '%s', master ptr [%p]\n",
+				 core->int_dev.name,
+				 core->int_dev.u.slave->attach_to,
+				 core->int_dev.u.slave->master);
+	DBG_PRINT("TVP5150:probe: i2c_client: [%p], i2c_device_id: [%p], core: [%p]\n",
+					c, id, core);
+
+	ret = v4l2_int_device_register(&core->int_dev);
+
+	clk_disable_unprepare(core->sen.sensor_clk);
+
+	DBG_PRINT("DONE ret %d,Registered to v4l2 master %s\n",
+				 ret, core->int_dev.u.slave->attach_to);
+
+	return ret;
+
+free_core:
+	kfree(core);
+	return res;
+
+}
+
+static int tvp5150_remove(struct i2c_client *c)
+{
+//	struct v4l2_subdev *sd = i2c_get_clientdata(c);
+//	struct tvp5150 *decoder = to_tvp5150(sd);
+
+	DBG_PRINT("tvp5150: removing tvp5150 adapter on address 0x%x\n", c->addr<<1);
+
+//TODO	v4l2_int_device_unregister(&tvp5150_int_device);
+//TODO	kfree(to_tvp5150(sd));
+	return 0;
+}
+
+/* ----------------------------------------------------------------------- */
+
+/*!
+ * TVP5150 init function.
+ * Called on insmod.
+ *
+ * @return    Error code indicating success or failure.
+ */
+static __init int tvp5150_init(void)
+{
+	u8 err = 0;
+
+	pr_debug("tvp5150_init\n");
+
+	/* Tells the i2c driver what functions to call for this driver. */
+	err = i2c_add_driver(&tvp5150_i2c_driver);
+	if (err != 0)
+		pr_err("%s:driver registration failed, error=%d\n",
+			__func__, err);
+	return err;
+}
+
+/*!
+ * TVP5150 exit function.
+ * Called on rmmod.
+ *
+ * @return   Error code indicating success or failure.
+ */
+static void __exit tvp5150_exit(void)
+{
+	DBG_PRINT("tvp5150_exit\n");
+	i2c_del_driver(&tvp5150_i2c_driver);
+}
+
+module_init(tvp5150_init);
+module_exit(tvp5150_exit);
+
+MODULE_AUTHOR("IpTronix S.r.l.");
+MODULE_DESCRIPTION("Texas Instruments TVP5150A video decoder driver");
+MODULE_LICENSE("GPL");
Index: git/drivers/media/platform/mxc/capture/tvp5150_reg.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/drivers/media/platform/mxc/capture/tvp5150_reg.h	2016-06-15 15:00:09.789442320 +0200
@@ -0,0 +1,139 @@
+/*
+ * tvp5150 - Texas Instruments TVP5150A/AM1 video decoder registers
+ *
+ * Copyright (c) 2005,2006 Mauro Carvalho Chehab (mchehab@infradead.org)
+ * This code is placed under the terms of the GNU General Public License v2
+ */
+
+#define TVP5150_VD_IN_SRC_SEL_1      0x00 /* Video input source selection #1 */
+#define TVP5150_ANAL_CHL_CTL         0x01 /* Analog channel controls */
+#define TVP5150_OP_MODE_CTL          0x02 /* Operation mode controls */
+#define TVP5150_MISC_CTL             0x03 /* Miscellaneous controls */
+#define TVP5150_AUTOSW_MSK           0x04 /* Autoswitch mask: TVP5150A / TVP5150AM */
+
+/* Reserved 05h */
+
+#define TVP5150_COLOR_KIL_THSH_CTL   0x06 /* Color killer threshold control */
+#define TVP5150_LUMA_PROC_CTL_1      0x07 /* Luminance processing control #1 */
+#define TVP5150_LUMA_PROC_CTL_2      0x08 /* Luminance processing control #2 */
+#define TVP5150_BRIGHT_CTL           0x09 /* Brightness control */
+#define TVP5150_SATURATION_CTL       0x0a /* Color saturation control */
+#define TVP5150_HUE_CTL              0x0b /* Hue control */
+#define TVP5150_CONTRAST_CTL         0x0c /* Contrast control */
+#define TVP5150_DATA_RATE_SEL        0x0d /* Outputs and data rates select */
+#define TVP5150_LUMA_PROC_CTL_3      0x0e /* Luminance processing control #3 */
+#define TVP5150_CONF_SHARED_PIN      0x0f /* Configuration shared pins */
+
+/* Reserved 10h */
+
+#define TVP5150_ACT_VD_CROP_ST_MSB   0x11 /* Active video cropping start MSB */
+#define TVP5150_ACT_VD_CROP_ST_LSB   0x12 /* Active video cropping start LSB */
+#define TVP5150_ACT_VD_CROP_STP_MSB  0x13 /* Active video cropping stop MSB */
+#define TVP5150_ACT_VD_CROP_STP_LSB  0x14 /* Active video cropping stop LSB */
+#define TVP5150_GENLOCK              0x15 /* Genlock/RTC */
+#define TVP5150_HORIZ_SYNC_START     0x16 /* Horizontal sync start */
+
+/* Reserved 17h */
+
+#define TVP5150_VERT_BLANKING_START 0x18 /* Vertical blanking start */
+#define TVP5150_VERT_BLANKING_STOP  0x19 /* Vertical blanking stop */
+#define TVP5150_CHROMA_PROC_CTL_1   0x1a /* Chrominance processing control #1 */
+#define TVP5150_CHROMA_PROC_CTL_2   0x1b /* Chrominance processing control #2 */
+#define TVP5150_INT_RESET_REG_B     0x1c /* Interrupt reset register B */
+#define TVP5150_INT_ENABLE_REG_B    0x1d /* Interrupt enable register B */
+#define TVP5150_INTT_CONFIG_REG_B   0x1e /* Interrupt configuration register B */
+
+/* Reserved 1Fh-27h */
+
+#define VIDEO_STD_MASK			 (0x07 >> 1)
+#define TVP5150_VIDEO_STD                0x28 /* Video standard */
+#define VIDEO_STD_AUTO_SWITCH_BIT	 0x00
+#define VIDEO_STD_NTSC_MJ_BIT		 0x02
+#define VIDEO_STD_PAL_BDGHIN_BIT	 0x04
+#define VIDEO_STD_PAL_M_BIT		 0x06
+#define VIDEO_STD_PAL_COMBINATION_N_BIT	 0x08
+#define VIDEO_STD_NTSC_4_43_BIT		 0x0a
+#define VIDEO_STD_SECAM_BIT		 0x0c
+
+#define VIDEO_STD_NTSC_MJ_BIT_AS                 0x01
+#define VIDEO_STD_PAL_BDGHIN_BIT_AS              0x03
+#define VIDEO_STD_PAL_M_BIT_AS		         0x05
+#define VIDEO_STD_PAL_COMBINATION_N_BIT_AS	 0x07
+#define VIDEO_STD_NTSC_4_43_BIT_AS		 0x09
+#define VIDEO_STD_SECAM_BIT_AS		         0x0b
+
+/* Reserved 29h-2bh */
+
+#define TVP5150_CB_GAIN_FACT        0x2c /* Cb gain factor */
+#define TVP5150_CR_GAIN_FACTOR      0x2d /* Cr gain factor */
+#define TVP5150_MACROVISION_ON_CTR  0x2e /* Macrovision on counter */
+#define TVP5150_MACROVISION_OFF_CTR 0x2f /* Macrovision off counter */
+#define TVP5150_REV_SELECT          0x30 /* revision select (TVP5150AM1 only) */
+
+/* Reserved	31h-7Fh */
+
+#define TVP5150_MSB_DEV_ID          0x80 /* MSB of device ID */
+#define TVP5150_LSB_DEV_ID          0x81 /* LSB of device ID */
+#define TVP5150_ROM_MAJOR_VER       0x82 /* ROM major version */
+#define TVP5150_ROM_MINOR_VER       0x83 /* ROM minor version */
+#define TVP5150_VERT_LN_COUNT_MSB   0x84 /* Vertical line count MSB */
+#define TVP5150_VERT_LN_COUNT_LSB   0x85 /* Vertical line count LSB */
+#define TVP5150_INT_STATUS_REG_B    0x86 /* Interrupt status register B */
+#define TVP5150_INT_ACTIVE_REG_B    0x87 /* Interrupt active register B */
+#define TVP5150_STATUS_REG_1        0x88 /* Status register #1 */
+#define TVP5150_STATUS_REG_2        0x89 /* Status register #2 */
+#define TVP5150_STATUS_REG_3        0x8a /* Status register #3 */
+#define TVP5150_STATUS_REG_4        0x8b /* Status register #4 */
+#define TVP5150_STATUS_REG_5        0x8c /* Status register #5 */
+/* Reserved	8Dh-8Fh */
+ /* Closed caption data registers */
+#define TVP5150_CC_DATA_INI         0x90
+#define TVP5150_CC_DATA_END         0x93
+
+ /* WSS data registers */
+#define TVP5150_WSS_DATA_INI        0x94
+#define TVP5150_WSS_DATA_END        0x99
+
+/* VPS data registers */
+#define TVP5150_VPS_DATA_INI        0x9a
+#define TVP5150_VPS_DATA_END        0xa6
+
+/* VITC data registers */
+#define TVP5150_VITC_DATA_INI       0xa7
+#define TVP5150_VITC_DATA_END       0xaf
+
+#define TVP5150_VBI_FIFO_READ_DATA  0xb0 /* VBI FIFO read data */
+
+/* Teletext filter 1 */
+#define TVP5150_TELETEXT_FIL1_INI  0xb1
+#define TVP5150_TELETEXT_FIL1_END  0xb5
+
+/* Teletext filter 2 */
+#define TVP5150_TELETEXT_FIL2_INI  0xb6
+#define TVP5150_TELETEXT_FIL2_END  0xba
+
+#define TVP5150_TELETEXT_FIL_ENA    0xbb /* Teletext filter enable */
+/* Reserved	BCh-BFh */
+#define TVP5150_INT_STATUS_REG_A    0xc0 /* Interrupt status register A */
+#define TVP5150_INT_ENABLE_REG_A    0xc1 /* Interrupt enable register A */
+#define TVP5150_INT_CONF            0xc2 /* Interrupt configuration */
+#define TVP5150_VDP_CONF_RAM_DATA   0xc3 /* VDP configuration RAM data */
+#define TVP5150_CONF_RAM_ADDR_LOW   0xc4 /* Configuration RAM address low byte */
+#define TVP5150_CONF_RAM_ADDR_HIGH  0xc5 /* Configuration RAM address high byte */
+#define TVP5150_VDP_STATUS_REG      0xc6 /* VDP status register */
+#define TVP5150_FIFO_WORD_COUNT     0xc7 /* FIFO word count */
+#define TVP5150_FIFO_INT_THRESHOLD  0xc8 /* FIFO interrupt threshold */
+#define TVP5150_FIFO_RESET          0xc9 /* FIFO reset */
+#define TVP5150_LINE_NUMBER_INT     0xca /* Line number interrupt */
+#define TVP5150_PIX_ALIGN_REG_LOW   0xcb /* Pixel alignment register low byte */
+#define TVP5150_PIX_ALIGN_REG_HIGH  0xcc /* Pixel alignment register high byte */
+#define TVP5150_FIFO_OUT_CTRL       0xcd /* FIFO output control */
+/* Reserved	CEh */
+#define TVP5150_FULL_FIELD_ENA      0xcf /* Full field enable 1 */
+
+/* Line mode registers */
+#define TVP5150_LINE_MODE_INI       0xd0
+#define TVP5150_LINE_MODE_END       0xfb
+
+#define TVP5150_FULL_FIELD_MODE_REG 0xfc /* Full field mode register */
+/* Reserved	FDh-FFh */
