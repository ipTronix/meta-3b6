Index: git/drivers/net/can/Kconfig
===================================================================
--- git.orig/drivers/net/can/Kconfig	2016-04-06 12:05:10.863041254 +0200
+++ git/drivers/net/can/Kconfig	2016-04-06 12:05:14.343041321 +0200
@@ -63,6 +63,13 @@
 	  Say Y here if you are working on a system with led-class supported
 	  LEDs and you want to use them as canbus activity indicators.
 
+config CAN_MCP2515
+	tristate "Microchip MCP2515 SPI CAN on TeraHE Altera FPGA"
+	depends on HAS_DMA
+	---help---
+	  Driver for the Microchip MCP2515 SPI CAN controllers connected to
+	  TeraHE Altera FPGA.
+
 config CAN_AT91
 	tristate "Atmel AT91 onchip CAN controller"
 	depends on (ARCH_AT91 || COMPILE_TEST) && HAS_IOMEM
Index: git/drivers/net/can/Makefile
===================================================================
--- git.orig/drivers/net/can/Makefile	2016-04-06 12:05:10.863041254 +0200
+++ git/drivers/net/can/Makefile	2016-04-06 12:05:14.343041321 +0200
@@ -14,6 +14,7 @@
 obj-y				+= usb/
 obj-y				+= softing/

+obj-$(CONFIG_CAN_MCP2515)	+= mcp2515.o
 obj-$(CONFIG_CAN_SJA1000)	+= sja1000/
 obj-$(CONFIG_CAN_MSCAN)		+= mscan/
 obj-$(CONFIG_CAN_C_CAN)		+= c_can/
Index: git/drivers/net/can/mcp2515.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/drivers/net/can/mcp2515.c	2016-04-12 15:00:29.205273022 +0200
@@ -0,0 +1,1357 @@
+/**
+ * CAN bus driver for Microchip 251% CAN Controller with SPI Interface
+ * connected on Tera HE Altera FPGA.
+ * Altera FPGA is connected on PCIe. This driver have to register itself
+ * to alter_cvifw driver to catch its interrupts.
+ */
+
+#include <linux/can/core.h>
+#include <linux/can/dev.h>
+#include <linux/can/led.h>
+#include <linux/can/platform/mcp251x.h>
+#include <linux/completion.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/dma-mapping.h>
+#include <linux/freezer.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/netdevice.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/spi/spi.h>
+#include <linux/uaccess.h>
+#include <linux/regulator/consumer.h>
+
+/* DEBUG HANDLING */
+//#define DEBUG
+#ifdef DEBUG
+  #define DBG_PRINT(fmt, ...)   printk("%s:%s:"fmt, DEVICE_NAME, __func__, ##__VA_ARGS__);
+  #define DBG_ERROR(fmt, ...)   printk("%s:%s:ERROR:"fmt, DEVICE_NAME, __func__, ##__VA_ARGS__);
+  #define DBG_IRQ_PRINT(x...) DBG_PRINT(x)
+  //#define DBG_IRQ_PRINT(x...)
+#else
+  #define DBG_PRINT(fmt, ...)
+  #define DBG_ERROR(fmt, ...)
+  #define DBG_IRQ_PRINT(x...)
+#endif
+
+/* SPI interface instruction set */
+#define INSTRUCTION_WRITE	0x02
+#define INSTRUCTION_READ	0x03
+#define INSTRUCTION_BIT_MODIFY	0x05
+#define INSTRUCTION_LOAD_TXB(n)	(0x40 + 2 * (n))
+#define INSTRUCTION_READ_RXB(n)	(((n) == 0) ? 0x90 : 0x94)
+#define INSTRUCTION_RESET	0xC0
+#define RTS_TXB0		0x01
+#define RTS_TXB1		0x02
+#define RTS_TXB2		0x04
+#define INSTRUCTION_RTS(n)	(0x80 | ((n) & 0x07))
+
+/* MPC251x registers */
+#define CANSTAT	      0x0e
+#define CANCTRL	      0x0f
+#  define CANCTRL_REQOP_MASK	    0xe0
+#  define CANCTRL_REQOP_CONF	    0x80
+#  define CANCTRL_REQOP_LISTEN_ONLY 0x60
+#  define CANCTRL_REQOP_LOOPBACK    0x40
+#  define CANCTRL_REQOP_SLEEP	    0x20
+#  define CANCTRL_REQOP_NORMAL	    0x00
+#  define CANCTRL_OSM		    0x08
+#  define CANCTRL_ABAT		    0x10
+#define TEC	      0x1c
+#define REC	      0x1d
+#define CNF1	      0x2a
+#  define CNF1_SJW_SHIFT   6
+#define CNF2	      0x29
+#  define CNF2_BTLMODE	   0x80
+#  define CNF2_SAM         0x40
+#  define CNF2_PS1_SHIFT   3
+#define CNF3	      0x28
+#  define CNF3_SOF	   0x08
+#  define CNF3_WAKFIL	   0x04
+#  define CNF3_PHSEG2_MASK 0x07
+#define CANINTE	      0x2b
+#  define CANINTE_MERRE 0x80
+#  define CANINTE_WAKIE 0x40
+#  define CANINTE_ERRIE 0x20
+#  define CANINTE_TX2IE 0x10
+#  define CANINTE_TX1IE 0x08
+#  define CANINTE_TX0IE 0x04
+#  define CANINTE_RX1IE 0x02
+#  define CANINTE_RX0IE 0x01
+#define CANINTF	      0x2c
+#  define CANINTF_MERRF 0x80
+#  define CANINTF_WAKIF 0x40
+#  define CANINTF_ERRIF 0x20
+#  define CANINTF_TX2IF 0x10
+#  define CANINTF_TX1IF 0x08
+#  define CANINTF_TX0IF 0x04
+#  define CANINTF_RX1IF 0x02
+#  define CANINTF_RX0IF 0x01
+#  define CANINTF_RX (CANINTF_RX0IF | CANINTF_RX1IF)
+#  define CANINTF_TX (CANINTF_TX2IF | CANINTF_TX1IF | CANINTF_TX0IF)
+#  define CANINTF_ERR (CANINTF_ERRIF)
+#define EFLG	      0x2d
+#  define EFLG_EWARN	0x01
+#  define EFLG_RXWAR	0x02
+#  define EFLG_TXWAR	0x04
+#  define EFLG_RXEP	0x08
+#  define EFLG_TXEP	0x10
+#  define EFLG_TXBO	0x20
+#  define EFLG_RX0OVR	0x40
+#  define EFLG_RX1OVR	0x80
+#define TXBCTRL(n)  (((n) * 0x10) + 0x30 + TXBCTRL_OFF)
+#  define TXBCTRL_ABTF	0x40
+#  define TXBCTRL_MLOA	0x20
+#  define TXBCTRL_TXERR 0x10
+#  define TXBCTRL_TXREQ 0x08
+#define TXBSIDH(n)  (((n) * 0x10) + 0x30 + TXBSIDH_OFF)
+#  define SIDH_SHIFT    3
+#define TXBSIDL(n)  (((n) * 0x10) + 0x30 + TXBSIDL_OFF)
+#  define SIDL_SID_MASK    7
+#  define SIDL_SID_SHIFT   5
+#  define SIDL_EXIDE_SHIFT 3
+#  define SIDL_EID_SHIFT   16
+#  define SIDL_EID_MASK    3
+#define TXBEID8(n)  (((n) * 0x10) + 0x30 + TXBEID8_OFF)
+#define TXBEID0(n)  (((n) * 0x10) + 0x30 + TXBEID0_OFF)
+#define TXBDLC(n)   (((n) * 0x10) + 0x30 + TXBDLC_OFF)
+#  define DLC_RTR_SHIFT    6
+#define TXBCTRL_OFF 0
+#define TXBSIDH_OFF 1
+#define TXBSIDL_OFF 2
+#define TXBEID8_OFF 3
+#define TXBEID0_OFF 4
+#define TXBDLC_OFF  5
+#define TXBDAT_OFF  6
+#define RXBCTRL(n)  (((n) * 0x10) + 0x60 + RXBCTRL_OFF)
+#  define RXBCTRL_BUKT	0x04
+#  define RXBCTRL_RXM0	0x20
+#  define RXBCTRL_RXM1	0x40
+#define RXBSIDH(n)  (((n) * 0x10) + 0x60 + RXBSIDH_OFF)
+#  define RXBSIDH_SHIFT 3
+#define RXBSIDL(n)  (((n) * 0x10) + 0x60 + RXBSIDL_OFF)
+#  define RXBSIDL_IDE   0x08
+#  define RXBSIDL_SRR   0x10
+#  define RXBSIDL_EID   3
+#  define RXBSIDL_SHIFT 5
+#define RXBEID8(n)  (((n) * 0x10) + 0x60 + RXBEID8_OFF)
+#define RXBEID0(n)  (((n) * 0x10) + 0x60 + RXBEID0_OFF)
+#define RXBDLC(n)   (((n) * 0x10) + 0x60 + RXBDLC_OFF)
+#  define RXBDLC_LEN_MASK  0x0f
+#  define RXBDLC_RTR       0x40
+#define RXBCTRL_OFF 0
+#define RXBSIDH_OFF 1
+#define RXBSIDL_OFF 2
+#define RXBEID8_OFF 3
+#define RXBEID0_OFF 4
+#define RXBDLC_OFF  5
+#define RXBDAT_OFF  6
+#define RXFSIDH(n) ((n) * 4)
+#define RXFSIDL(n) ((n) * 4 + 1)
+#define RXFEID8(n) ((n) * 4 + 2)
+#define RXFEID0(n) ((n) * 4 + 3)
+#define RXMSIDH(n) ((n) * 4 + 0x20)
+#define RXMSIDL(n) ((n) * 4 + 0x21)
+#define RXMEID8(n) ((n) * 4 + 0x22)
+#define RXMEID0(n) ((n) * 4 + 0x23)
+
+#define GET_BYTE(val, byte)			\
+	(((val) >> ((byte) * 8)) & 0xff)
+#define SET_BYTE(val, byte)			\
+	(((val) & 0xff) << ((byte) * 8))
+
+/*
+ * Buffer size required for the largest SPI transfer (i.e., reading a frame)
+ */
+#define CAN_FRAME_MAX_DATA_LEN	8
+#define SPI_TRANSFER_BUF_LEN	(6 + CAN_FRAME_MAX_DATA_LEN)
+#define CAN_FRAME_MAX_BITS	128
+
+#define TX_ECHO_SKB_MAX	1
+
+#define DEVICE_NAME "mcp2515"
+
+/**
+ * PCIe FPGA MCP2515 SPI device address definitions
+ */
+#define SPI_MCP2515_SIZE    0x400
+
+#define SPI_MCP2515_MB_RX_BASE    0x00004500
+#define SPI_MCP2515_MB_TX_BASE    0x00004510
+#define SPI_MCP2515_0_BASE        0x00005000
+#define SPI_MCP2515_1_BASE        (SPI_MCP2515_0_BASE+SPI_MCP2515_SIZE)
+
+#define SPI_MCP2515_TXB   0x0000
+#define SPI_MCP2515_RXB   0x0020
+#define SPI_MCP2515_BUF   0x0040
+
+#define SPI_MCP2515_BUF_SIZE   0x0020
+#define SPI_MCP2515_BUF_NUM    ((SPI_MCP2515_SIZE-SPI_MCP2515_BUF)/SPI_MCP2515_BUF_SIZE)
+
+/**
+ * Altera Avalon Mailbox
+ *
+ * A write to the command register by the sender processor indicates a pending
+ * message in the Mailbox and an interrupt will be issued to the receiver
+ * processor.
+ * Upon retrieval of the message by the receiver processor via a read
+ * transaction, the message is consumed, Mailbox is empty.
+ * The status register (0x2) is used to indicate if the Mailbox is full or empty.
+ *
+ * Interrupt Masking Register (0x3) is writable by the Avalon-MM interface to
+ * mask its dedicated interrupt output.
+ */
+
+#define SPI_MCP2515_CMD_REG   0x0000  // R/W for sender, RO for receiver
+#define SPI_MCP2515_PTR_REG   0x0004  // R/W for sender, RO for receiver
+#define SPI_MCP2515_STS_REG   0x0008  // RO
+#define SPI_MCP2515_STS_PENDING 0x00000001  // Message pending
+#define SPI_MCP2515_STS_FULL    0x00000002  // Mailbox full
+#define SPI_MCP2515_IMR_REG   0x000C  // Read (R) for both sender and receiver.
+                                      // Sender can only write to Message Space
+                                      // Interrupt Mask bit, Receiver can only
+                                      // write to Message Pending Interrupt bit.
+#define SPI_MCP2515_IMR_PENDING 0x00000001  // Message pending mask
+#define SPI_MCP2515_IMR_FULL    0x00000002  // Mailbox space mask
+
+
+#define MB_CMD_READ(b)    __raw_readl(b + SPI_MCP2515_CMD_REG)
+#define MB_PTR_READ(b)    __raw_readl(b + SPI_MCP2515_PTR_REG)
+#define MB_STS_READ(b)    __raw_readl(b + SPI_MCP2515_STS_REG)
+
+#define MB_INT_ENABLE(b)  __raw_writel(SPI_MCP2515_IMR_PENDING, b + SPI_MCP2515_IMR_REG)
+#define MB_INT_DISABLE(b) __raw_writel(0, b + SPI_MCP2515_IMR_REG)
+
+/**
+ * module parameters definition
+ */
+static int mcp2515_enable_dma; /* Enable SPI DMA. Default: 0 (Off) */
+module_param(mcp2515_enable_dma, int, S_IRUGO);
+MODULE_PARM_DESC(mcp2515_enable_dma, "Enable SPI DMA. Default: 0 (Off)");
+
+/**
+ * CAN bit timing
+ */
+static const struct can_bittiming_const mcp2515_bittiming_const = {
+	.name      = DEVICE_NAME,
+	.tseg1_min =  3,
+	.tseg1_max = 16,
+	.tseg2_min =  2,
+	.tseg2_max =  8,
+	.sjw_max   =  4,
+	.brp_min   =  1,
+	.brp_max   = 64,
+	.brp_inc   =  1,
+};
+
+/**
+ * device definition structure
+ */
+struct mcp2515_device {
+	struct can_priv           can;
+	struct net_device        *net;
+
+	struct mutex              mcp_lock; /* SPI device lock */
+
+	u8                       *spi_tx_buf;
+	u8                       *spi_rx_buf;
+	dma_addr_t                spi_tx_dma;
+	dma_addr_t                spi_rx_dma;
+
+	struct sk_buff           *tx_skb;
+	int                       tx_len;
+
+	struct workqueue_struct  *wq;
+	struct work_struct        tx_work;
+	struct work_struct        restart_work;
+
+	int                       force_quit;
+	int                       after_suspend;
+#define AFTER_SUSPEND_UP      1
+#define AFTER_SUSPEND_DOWN    2
+#define AFTER_SUSPEND_POWER   4
+#define AFTER_SUSPEND_RESTART 8
+	int                       restart_tx;
+
+	int                       index;
+	char                     *spi_mcp2515_base;
+	wait_queue_head_t         spi_wait;
+	int                       spi_done;
+
+#define FLG_HW_PROBE_DONE   0x00000001
+	u32                       flags;
+};
+
+#define MCP2515_NUM_DEV 2
+
+/**
+ * driver definition structure
+ */
+struct mcp2515_driver {
+	struct net_device        *net[MCP2515_NUM_DEV];
+	void __iomem             *pcie_bar0;
+	char                     *mbrx_base;
+	char                     *mbtx_base;
+	struct mutex              spi_lock; /* SPI transfer device lock */
+};
+
+struct mcp2515_driver   mcp2515_drv;
+
+static void mcp2515_hw_rx(struct mcp2515_device *dev, u8* buf);
+static void mcp2515_error_skb(struct net_device *net, int can_id, int data1);
+static void mcp2515_hw_sleep(struct mcp2515_device *dev);
+static int  mcp2515_isr_hook(void* arg);
+
+/**
+ * routine to attach to cvifw PCIe isr, return BAR0 address
+ */
+extern void __iomem* cvifw_device_attach(int (*hook)(void*), void* arg);
+
+/**
+ */
+void __iomem* irq_attach(void)
+{
+	void __iomem* base;
+	DBG_PRINT("\n");
+	/* Attach interrupt hook  */
+	base = cvifw_device_attach(mcp2515_isr_hook, &mcp2515_drv);
+	if ( !base ) {
+		return NULL;
+	}
+	/* Enable ALTERA SPI MCP2515 mailbox interrupt mask */
+	MB_INT_ENABLE(mcp2515_drv.mbrx_base);
+	return base;
+}
+
+/**
+ */
+void __iomem* irq_detach(void)
+{
+	void __iomem *base;
+
+	DBG_PRINT("\n");
+	/* Disable ALTERA SPI MCP2515 mailbox interrupt mask */
+	if (mcp2515_drv.mbrx_base) {
+		MB_INT_DISABLE(mcp2515_drv.mbrx_base);
+	}
+	/* Detach interrupt hook  */
+	base = cvifw_device_attach(NULL, NULL);
+	return base;
+}
+
+/**
+ */
+static void mcp2515_clean(struct net_device *net)
+{
+	struct mcp2515_device *priv = netdev_priv(net);
+
+	if (priv->tx_skb || priv->tx_len)
+		net->stats.tx_errors++;
+	if (priv->tx_skb)
+		dev_kfree_skb(priv->tx_skb);
+	if (priv->tx_len)
+		can_free_echo_skb(priv->net, 0);
+	priv->tx_skb = NULL;
+	priv->tx_len = 0;
+}
+
+/**
+ */
+static int mcp2515_spi_trans(struct mcp2515_device *dev, int len)
+{
+	int i;
+	int ret;
+
+	mutex_lock(&mcp2515_drv.spi_lock);
+
+	dev->spi_done = 0;
+	/* wait for Mailbox */
+	for (i=0; i<10000; i++) {
+		ret = MB_STS_READ(mcp2515_drv.mbtx_base);
+		if ( !(ret & SPI_MCP2515_STS_FULL) ) {
+			break;
+		}
+	}
+	if (i>=10000) {
+		DBG_ERROR("device %d:Mailbox tx timeout expired\n", dev->index);
+		mutex_unlock(&mcp2515_drv.spi_lock);
+		return -ETIMEDOUT;
+	}
+	for (i=0; i<len; i++) {
+		__raw_writeb(dev->spi_tx_buf[i], dev->spi_mcp2515_base+SPI_MCP2515_TXB+i);
+	}
+
+	/* writing MailBox command register to start SPI transfer */
+	len |= (dev->index << 8);
+	__raw_writel(len, mcp2515_drv.mbtx_base + SPI_MCP2515_CMD_REG);
+
+	/* waiting for MailBox SPI transfer completion */
+	ret = wait_event_interruptible_timeout(dev->spi_wait, dev->spi_done, 2*HZ);
+	if (ret == 0) {
+		DBG_ERROR("device %d:SPI timeout expired\n", dev->index);
+		mutex_unlock(&mcp2515_drv.spi_lock);
+		return -ETIMEDOUT;
+	}
+
+	/* copy SPI response */
+	for (i=0; i<len; i++) {
+		dev->spi_rx_buf[i] = __raw_readb(dev->spi_mcp2515_base+SPI_MCP2515_RXB+i);
+	}
+	mutex_unlock(&mcp2515_drv.spi_lock);
+	return 0;
+}
+
+/**
+#define MSG_FLAGS_OFFS    0
+#define MSG_EFLG_OFFS     1
+#define MSG_IFLG_OFFS     2
+#define MSG_CANBUF1_OFFS  3
+#define MSG_CANBUF2_OFFS 17
+
+#define RXB0_VALID      0x01
+#define RXB1_VALID      0x02
+
+ * prende il messaggio dalla coda
+ * verifica se è una notifica di fine transazione SPI
+ *  sblocca la routine di trasferimento SPI
+ * oppure se è un messaggio CAN ricevuto
+ *  estrae eflag e intf dal messaggio ed esegue i controlli seguenti
+ *  struttura messaggio
+ *  byte  0 flags
+ *          RXB0_VALID      0x01
+ *          RXB1_VALID      0x02
+ *  byte  1 eflag
+ *          cfr MCP2515 datasheet
+ *  byte  2 iflag
+ *          cfr MCP2515 datasheet
+ *  byte  3 CAN Messagge Buffer 0
+ *  byte 17 CAN Messagge Buffer 1
+ *
+ */
+
+#define RXB0_VALID  0x01
+#define RXB1_VALID  0x02
+
+#ifdef DEBUG
+static int int_cnt_spi = 0;
+static int int_cnt_msg = 0;
+#endif
+
+static int mcp2515_isr_hook(void* arg)
+{
+	struct mcp2515_driver  *drv = (struct mcp2515_driver*)arg;
+	struct net_device      *net;
+	struct mcp2515_device  *dev;
+	u32                     sts;
+	u32                     ptr;
+	int                     index;
+
+	/* mailbox check */
+	sts = MB_STS_READ(drv->mbrx_base);
+	if ( !( sts & SPI_MCP2515_STS_PENDING ) ) {
+		DBG_IRQ_PRINT("-\n");
+		return 0;
+	}
+
+	/* get pointer from mailbox */
+	ptr = MB_PTR_READ(drv->mbrx_base);
+	index = ptr & 0x00000001;
+
+	if(drv->net[index]==NULL){
+		DBG_ERROR("drv->net is NULL\n");
+		MB_CMD_READ(drv->mbrx_base);
+		return 1;
+	}
+	net = drv->net[index];
+	dev = netdev_priv(net);
+
+	/* spi transfer completed. */
+	if ( (ptr & 0x80000000) == 0x00000000 ) {
+#ifdef DEBUG
+		int_cnt_spi++;
+		DBG_IRQ_PRINT("index %d:spi transfer completed %d\n", index, int_cnt_spi);
+#endif
+		MB_CMD_READ(drv->mbrx_base);
+		dev->spi_done = 1;
+		wake_up(&dev->spi_wait);
+		return 1;
+	}
+
+	/** Interrupt message from MCP2515.
+	 *  Can be incoming CAN message, tx completion or error.
+	 */
+	if ( (ptr & 0x80000000) == 0x80000000 ) {
+		int             idx = (ptr >> 1) & 0x1F; // indice del buffer da leggere
+		int             cnt = (ptr >> 6) & 0x1F; // numero di buffer da leggere
+		//int             num = (ptr >> 11) & 0x1F; // numero totale di buffer nella coda dell'FPGA
+		int             i;
+		u8              eflag;
+		u8              intf ;
+		u8              buf[32];//SPI_TRANSFER_BUF_LEN];
+    enum can_state  new_state;
+		canid_t         can_id = 0;
+		u8              data1  = 0;
+
+		for (i=0; i<cnt; i++) {
+			/* get message form SPI_MCP2515_BUF queue */
+			{
+				u8   *a;
+				int   b;
+				a = dev->spi_mcp2515_base + SPI_MCP2515_BUF + SPI_MCP2515_BUF_SIZE * idx;
+				for (b=0; b<32; b++) {
+					buf[b] = __raw_readb(a+b);
+				}
+			}
+
+			if ( buf[0] & RXB0_VALID ) {
+				mcp2515_hw_rx(dev, buf+3);
+			}
+			if ( buf[0] & RXB1_VALID ) {
+				mcp2515_hw_rx(dev, buf+17);
+			}
+			eflag = buf[1];
+			intf  = buf[2];
+
+			/* Update can state */
+			if (eflag & EFLG_TXBO) {
+				new_state = CAN_STATE_BUS_OFF;
+				can_id |= CAN_ERR_BUSOFF;
+			} else if (eflag & EFLG_TXEP) {
+				new_state = CAN_STATE_ERROR_PASSIVE;
+				can_id |= CAN_ERR_CRTL;
+				data1 |= CAN_ERR_CRTL_TX_PASSIVE;
+			} else if (eflag & EFLG_RXEP) {
+				new_state = CAN_STATE_ERROR_PASSIVE;
+				can_id |= CAN_ERR_CRTL;
+				data1 |= CAN_ERR_CRTL_RX_PASSIVE;
+			} else if (eflag & EFLG_TXWAR) {
+				new_state = CAN_STATE_ERROR_WARNING;
+				can_id |= CAN_ERR_CRTL;
+				data1 |= CAN_ERR_CRTL_TX_WARNING;
+			} else if (eflag & EFLG_RXWAR) {
+				new_state = CAN_STATE_ERROR_WARNING;
+				can_id |= CAN_ERR_CRTL;
+				data1 |= CAN_ERR_CRTL_RX_WARNING;
+			} else {
+				new_state = CAN_STATE_ERROR_ACTIVE;
+			}
+
+			/* Update can state statistics */
+			switch (dev->can.state) {
+			case CAN_STATE_ERROR_ACTIVE:
+				if (new_state >= CAN_STATE_ERROR_WARNING &&
+						new_state <= CAN_STATE_BUS_OFF) {
+					dev->can.can_stats.error_warning++;
+				}
+			case CAN_STATE_ERROR_WARNING:  // fallthrough
+				if (new_state >= CAN_STATE_ERROR_PASSIVE &&
+						new_state <= CAN_STATE_BUS_OFF) {
+					dev->can.can_stats.error_passive++;
+				}
+				break;
+			default:
+				break;
+			}
+			dev->can.state = new_state;
+
+			if (intf & CANINTF_ERRIF) {
+				/* Handle overflow counters */
+				if (eflag & (EFLG_RX0OVR | EFLG_RX1OVR)) {
+					if (eflag & EFLG_RX0OVR) {
+						net->stats.rx_over_errors++;
+						net->stats.rx_errors++;
+					}
+					if (eflag & EFLG_RX1OVR) {
+						net->stats.rx_over_errors++;
+						net->stats.rx_errors++;
+					}
+					can_id |= CAN_ERR_CRTL;
+					data1  |= CAN_ERR_CRTL_RX_OVERFLOW;
+				}
+				mcp2515_error_skb(net, can_id, data1);
+			}
+
+			if (dev->can.state == CAN_STATE_BUS_OFF) {
+				if (dev->can.restart_ms == 0) {
+					/*
+					dev->force_quit = 1;
+					can_bus_off(net);
+					DBG_ERROR("CAN_STATE_BUS_OFF call hw_sleep\n");
+					mcp2515_hw_sleep(dev); TODO deve farla chiamare da un task
+					*/
+					queue_work(dev->wq, &dev->tx_work);
+					break;
+				}
+			}
+
+			if (intf & CANINTF_TX) {
+				net->stats.tx_packets++;
+				net->stats.tx_bytes += dev->tx_len - 1;
+				can_led_event(net, CAN_LED_EVENT_TX);
+				if (dev->tx_len) {
+					can_get_echo_skb(net, 0);
+					/* TODO mod gest tx */			dev->tx_skb = NULL;
+					dev->tx_len = 0;
+				}
+				netif_wake_queue(net);
+			}
+			idx++;
+			idx %= SPI_MCP2515_BUF_NUM;
+		}
+#ifdef DEBUG
+		int_cnt_msg++;
+		DBG_IRQ_PRINT("index %d:Interrupt message from MCP2515 Mailbox %d\n",
+		              index, int_cnt_msg);
+#endif
+		MB_CMD_READ(drv->mbrx_base);
+		return 1;
+	}
+	return 0;
+}
+
+static u8 mcp2515_read_reg(struct mcp2515_device *dev, uint8_t reg)
+{
+	u8 val = 0;
+
+	dev->spi_tx_buf[0] = INSTRUCTION_READ;
+	dev->spi_tx_buf[1] = reg;
+	mcp2515_spi_trans(dev, 3);
+	val = dev->spi_rx_buf[2];
+	return val;
+}
+
+static void mcp2515_write_reg(struct mcp2515_device *dev, u8 reg, uint8_t val)
+{
+	dev->spi_tx_buf[0] = INSTRUCTION_WRITE;
+	dev->spi_tx_buf[1] = reg;
+	dev->spi_tx_buf[2] = val;
+	mcp2515_spi_trans(dev, 3);
+}
+
+static void mcp2515_write_bits(struct mcp2515_device *dev, u8 reg,
+			       u8 mask, uint8_t val)
+{
+	dev->spi_tx_buf[0] = INSTRUCTION_BIT_MODIFY;
+	dev->spi_tx_buf[1] = reg;
+	dev->spi_tx_buf[2] = mask;
+	dev->spi_tx_buf[3] = val;
+	mcp2515_spi_trans(dev, 4);
+}
+
+static void mcp2515_hw_tx(struct mcp2515_device *dev, struct can_frame *frame,
+			  int tx_buf_idx)
+{
+	u32   sid, eid, exide, rtr;
+	u8   *buf;
+
+	exide = (frame->can_id & CAN_EFF_FLAG) ? 1 : 0; /* Extended ID Enable */
+	if (exide)
+		sid = (frame->can_id & CAN_EFF_MASK) >> 18;
+	else
+		sid = frame->can_id & CAN_SFF_MASK; /* Standard ID */
+	eid = frame->can_id & CAN_EFF_MASK; /* Extended ID */
+	rtr = (frame->can_id & CAN_RTR_FLAG) ? 1 : 0; /* Remote transmission */
+
+	buf = dev->spi_tx_buf;
+	buf[TXBCTRL_OFF] = INSTRUCTION_LOAD_TXB(tx_buf_idx);
+	buf[TXBSIDH_OFF] = sid >> SIDH_SHIFT;
+	buf[TXBSIDL_OFF] = ((sid & SIDL_SID_MASK) << SIDL_SID_SHIFT) |
+	                   (exide << SIDL_EXIDE_SHIFT) |
+	                   ((eid >> SIDL_EID_SHIFT) & SIDL_EID_MASK);
+	buf[TXBEID8_OFF] = GET_BYTE(eid, 1);
+	buf[TXBEID0_OFF] = GET_BYTE(eid, 0);
+	buf[TXBDLC_OFF]  = (rtr << DLC_RTR_SHIFT) | frame->can_dlc;
+	memcpy(buf + TXBDAT_OFF, frame->data, frame->can_dlc);
+	mcp2515_spi_trans(dev, TXBDAT_OFF + frame->can_dlc);
+
+	/* use INSTRUCTION_RTS, to avoid "repeated frame problem" */
+	dev->spi_tx_buf[0] = INSTRUCTION_RTS(1 << tx_buf_idx);
+	mcp2515_spi_trans(dev, 1);
+}
+
+/**
+ * Read incoming message
+ */
+static void mcp2515_hw_rx(struct mcp2515_device *dev, u8* buf)
+{
+	struct sk_buff   *skb;
+	struct can_frame *frame;
+
+	skb = alloc_can_skb(dev->net, &frame);
+	if (!skb) {
+		DBG_ERROR("cannot allocate RX skb\n");
+		dev->net->stats.rx_dropped++;
+		return;
+	}
+
+	if (buf[RXBSIDL_OFF] & RXBSIDL_IDE) {
+		/* Extended ID format */
+		frame->can_id = CAN_EFF_FLAG;
+		frame->can_id |=
+			/* Extended ID part */
+			SET_BYTE(buf[RXBSIDL_OFF] & RXBSIDL_EID, 2) |
+			SET_BYTE(buf[RXBEID8_OFF], 1) |
+			SET_BYTE(buf[RXBEID0_OFF], 0) |
+			/* Standard ID part */
+			(((buf[RXBSIDH_OFF] << RXBSIDH_SHIFT) |
+			  (buf[RXBSIDL_OFF] >> RXBSIDL_SHIFT)) << 18);
+		/* Remote transmission request */
+		if (buf[RXBDLC_OFF] & RXBDLC_RTR)
+			frame->can_id |= CAN_RTR_FLAG;
+	} else {
+		/* Standard ID format */
+		frame->can_id =
+			(buf[RXBSIDH_OFF] << RXBSIDH_SHIFT) |
+			(buf[RXBSIDL_OFF] >> RXBSIDL_SHIFT);
+		if (buf[RXBSIDL_OFF] & RXBSIDL_SRR)
+			frame->can_id |= CAN_RTR_FLAG;
+	}
+	/* Data length */
+	frame->can_dlc = get_can_dlc(buf[RXBDLC_OFF] & RXBDLC_LEN_MASK);
+	memcpy(frame->data, buf + RXBDAT_OFF, frame->can_dlc);
+
+	dev->net->stats.rx_packets++;
+	dev->net->stats.rx_bytes += frame->can_dlc;
+
+	can_led_event(dev->net, CAN_LED_EVENT_RX);
+
+	netif_rx_ni(skb);
+}
+
+static void mcp2515_hw_sleep(struct mcp2515_device *dev)
+{
+	mcp2515_write_reg(dev, CANCTRL, CANCTRL_REQOP_SLEEP);
+}
+
+static netdev_tx_t mcp2515_hard_start_xmit(struct sk_buff *skb,
+                                           struct net_device *net)
+{
+	struct mcp2515_device *priv = netdev_priv(net);
+
+	if (priv->tx_skb || priv->tx_len) {//TODO mod gest tx modificare in flag sent
+		DBG_ERROR("device %d:called while tx is busy tx_skb %p tx_len %d\n",
+		          priv->index, priv->tx_skb, priv->tx_len);
+		return NETDEV_TX_BUSY;
+	}
+	if (can_dropped_invalid_skb(net, skb)) {
+		DBG_ERROR("device %d:dropped invalid skb\n", priv->index);
+		return NETDEV_TX_OK;
+	}
+
+	netif_stop_queue(net);
+	priv->tx_skb = skb;
+	queue_work(priv->wq, &priv->tx_work);
+
+	return NETDEV_TX_OK;
+}
+
+static int mcp2515_do_set_mode(struct net_device *net, enum can_mode mode)
+{
+	struct mcp2515_device *priv = netdev_priv(net);
+
+	switch (mode) {
+	case CAN_MODE_START:
+		mcp2515_clean(net);
+		/* We have to delay work since SPI I/O may sleep */
+		priv->can.state = CAN_STATE_ERROR_ACTIVE;
+		priv->restart_tx = 1;
+		if (priv->can.restart_ms == 0)
+			priv->after_suspend = AFTER_SUSPEND_RESTART;
+		queue_work(priv->wq, &priv->restart_work);
+		break;
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	return 0;
+}
+
+static int mcp2515_set_normal_mode(struct mcp2515_device *dev)
+{
+	unsigned long timeout;
+
+	/* Enable interrupts */
+	mcp2515_write_reg(dev, CANINTE,
+	                  CANINTE_ERRIE | CANINTE_TX2IE | CANINTE_TX1IE |
+	                  CANINTE_TX0IE | CANINTE_RX1IE | CANINTE_RX0IE );
+
+	if (dev->can.ctrlmode & CAN_CTRLMODE_LOOPBACK) {
+		/* Put device into loopback mode */
+		mcp2515_write_reg(dev, CANCTRL, CANCTRL_REQOP_LOOPBACK);
+	} else if (dev->can.ctrlmode & CAN_CTRLMODE_LISTENONLY) {
+		/* Put device into listen-only mode */
+		mcp2515_write_reg(dev, CANCTRL, CANCTRL_REQOP_LISTEN_ONLY);
+	} else {
+		/* Put device into normal mode */
+		mcp2515_write_reg(dev, CANCTRL, CANCTRL_REQOP_NORMAL);
+
+		/* Wait for the device to enter normal mode */
+		timeout = jiffies + HZ;
+		while (mcp2515_read_reg(dev, CANSTAT) & CANCTRL_REQOP_MASK) {
+			schedule();
+			if (time_after(jiffies, timeout)) {
+				DBG_ERROR("MCP2515 didn't enter in normal mode\n");
+				return -EBUSY;
+			}
+		}
+	}
+	dev->can.state = CAN_STATE_ERROR_ACTIVE;
+	return 0;
+}
+
+static int mcp2515_do_set_bittiming(struct net_device *net)
+{
+	struct mcp2515_device *priv = netdev_priv(net);
+	struct can_bittiming  *bt   = &priv->can.bittiming;
+
+	DBG_PRINT("\n"
+	          "bitrate      %d\n"
+	          "sample_point %d\n"
+	          "sjw          %d\n"
+	          "brp          %d\n"
+	          "prop_seg     %d\n"
+	          "phase_seg1   %d\n"
+	          "phase_seg2   %d\n",
+	          bt->bitrate     ,
+	          bt->sample_point,
+	          bt->sjw         ,
+	          bt->brp         ,
+	          bt->prop_seg    ,
+	          bt->phase_seg1  ,
+	          bt->phase_seg2  );
+
+	mcp2515_write_reg(priv, CNF1, ((bt->sjw - 1) << CNF1_SJW_SHIFT) |
+	                  (bt->brp - 1));
+	mcp2515_write_reg(priv, CNF2, CNF2_BTLMODE |
+	                  (priv->can.ctrlmode & CAN_CTRLMODE_3_SAMPLES ?
+	                   CNF2_SAM : 0) |
+	                  ((bt->phase_seg1 - 1) << CNF2_PS1_SHIFT) |
+	                  (bt->prop_seg - 1));
+	mcp2515_write_bits(priv, CNF3, CNF3_PHSEG2_MASK,
+	                   (bt->phase_seg2 - 1));
+	DBG_PRINT("CNF: 0x%02x 0x%02x 0x%02x\n",
+	          mcp2515_read_reg(priv, CNF1),
+	          mcp2515_read_reg(priv, CNF2),
+	          mcp2515_read_reg(priv, CNF3));
+
+	return 0;
+}
+
+static int mcp2515_setup(struct net_device *net, struct mcp2515_device *dev)
+{
+	mcp2515_do_set_bittiming(net);
+
+	mcp2515_write_reg(dev, RXBCTRL(0),
+	                  RXBCTRL_BUKT | RXBCTRL_RXM0 | RXBCTRL_RXM1);
+	mcp2515_write_reg(dev, RXBCTRL(1),
+	                  RXBCTRL_RXM0 | RXBCTRL_RXM1);
+
+	return 0;
+}
+
+static int mcp2515_hw_reset(struct mcp2515_device *dev)
+{
+	int                     ret;
+	unsigned long           timeout;
+
+	dev->spi_tx_buf[0] = INSTRUCTION_RESET;
+	ret = mcp2515_spi_trans(dev, 1);
+	if (ret) {
+		DBG_ERROR("reset failed: ret = %d\n", ret);
+		return -EIO;
+	}
+
+	/* Wait for reset to finish */
+	timeout = jiffies + HZ;
+	mdelay(10);
+	while ((mcp2515_read_reg(dev, CANSTAT) & CANCTRL_REQOP_MASK)
+	       != CANCTRL_REQOP_CONF) {
+		schedule();
+		if (time_after(jiffies, timeout)) {
+			DBG_ERROR("MCP2515 didn't enter in conf mode after reset\n");
+			return -EBUSY;
+		}
+	}
+	return 0;
+}
+
+static int mcp2515_hw_probe(struct mcp2515_device *dev)
+{
+	int st1, st2;
+
+	mcp2515_hw_reset(dev);
+
+	/* Please note that these are "magic values" based on after    *
+	 * reset defaults taken from data sheet which allows us to see *
+	 * if we really have a chip on the bus (we avoid common all    *
+	 * zeroes or all ones situations)                              */
+	st1 = mcp2515_read_reg(dev, CANSTAT) & 0xEE;
+	st2 = mcp2515_read_reg(dev, CANCTRL) & 0x17;
+	DBG_PRINT("CANSTAT 0x%02x CANCTRL 0x%02x\n", st1, st2);
+
+	/* Check for power up default values */
+	return (st1 == 0x80 && st2 == 0x07) ? 1 : 0;
+}
+
+/**
+ * clear interrupt hook on PCIe isr manager.
+ * check if all devices are stopped
+ */
+static void mcp2515_open_clean(struct net_device *net)
+{
+	struct mcp2515_device *priv = netdev_priv(net);
+	int i;
+	int cs;
+
+DBG_PRINT("\n");
+	for(i=0; i<MCP2515_NUM_DEV; i++){
+		cs = ((struct mcp2515_device *)netdev_priv(mcp2515_drv.net[i]))->can.state;
+#ifdef DEBUG
+		{
+		char*des;
+		switch(cs){
+		case CAN_STATE_ERROR_ACTIVE     : des = "CAN controller is error active"; break;
+		case CAN_STATE_ERROR_WARNING    : des = "CAN controller is error active, warning level is reached"; break;
+		case CAN_STATE_ERROR_PASSIVE    : des = "CAN controller is error passive"; break;
+		case CAN_STATE_BUS_OFF          : des = "CAN controller went into Bus Off"; break;
+		case CAN_STATE_STOPPED          : des = "CAN controller is in stopped mode"; break;
+		case CAN_STATE_SLEEPING         : des = "CAN controller is in Sleep mode"; break;
+		default                         : des = "CAN controller is unknown state"; break;
+		}
+		DBG_PRINT("device %d:CAN State: %d %s\n", i, cs, des);
+		}
+#endif
+		if (cs != CAN_STATE_STOPPED) {
+			break;
+		}
+	}
+	if (i>=MCP2515_NUM_DEV) {
+		DBG_PRINT("Detach irq from altera_cvi driver\n");
+		irq_detach();
+	}
+
+	mcp2515_hw_sleep(priv);
+	close_candev(net);
+}
+
+static int mcp2515_stop(struct net_device *net)
+{
+	struct mcp2515_device *priv = netdev_priv(net);
+	DBG_PRINT("\n");
+
+	close_candev(net);
+
+	priv->force_quit = 1;
+
+	destroy_workqueue(priv->wq);
+	priv->wq = NULL;
+
+	mutex_lock(&priv->mcp_lock);
+
+	/* Disable and clear pending interrupts */
+	mcp2515_write_reg(priv, CANINTE, 0x00);
+	mcp2515_write_reg(priv, CANINTF, 0x00);
+
+	mcp2515_write_reg(priv, TXBCTRL(0), 0);
+	mcp2515_clean(net);
+
+	mcp2515_hw_sleep(priv);
+
+	priv->can.state = CAN_STATE_STOPPED;
+
+	mutex_unlock(&priv->mcp_lock);
+
+	/* clear interrupt hook on PCIe isr manager.
+	 * check if all devices are stopped    */
+	{
+		int i;
+		int cs;
+		for(i=0; i<MCP2515_NUM_DEV; i++){
+			cs = ((struct mcp2515_device *)netdev_priv(mcp2515_drv.net[i]))->can.state;
+#ifdef DEBUG
+			{
+			char*des;
+			switch(cs){
+			case CAN_STATE_ERROR_ACTIVE     : des = "CAN controller is error active"; break;
+			case CAN_STATE_ERROR_WARNING    : des = "CAN controller is error active, warning level is reached"; break;
+			case CAN_STATE_ERROR_PASSIVE    : des = "CAN controller is error passive"; break;
+			case CAN_STATE_BUS_OFF          : des = "CAN controller went into Bus Off"; break;
+			case CAN_STATE_STOPPED          : des = "CAN controller is in stopped mode"; break;
+			case CAN_STATE_SLEEPING         : des = "CAN controller is in Sleep mode"; break;
+			default                         : des = "CAN controller is unknown state"; break;
+			}
+			DBG_PRINT("device %d:CAN State:%d %s\n", i, cs, des);
+			}
+#endif
+			if (cs != CAN_STATE_STOPPED) {
+				break;
+			}
+		}
+		if (i>=MCP2515_NUM_DEV) {
+			DBG_PRINT("Detach irq from altera_cvi driver\n");
+			irq_detach();
+		}
+	}
+
+	can_led_event(net, CAN_LED_EVENT_STOP);
+
+	return 0;
+}
+
+static void mcp2515_error_skb(struct net_device *net, int can_id, int data1)
+{
+	struct sk_buff *skb;
+	struct can_frame *frame;
+
+	skb = alloc_can_err_skb(net, &frame);
+	if (skb) {
+		frame->can_id |= can_id;
+		frame->data[1] = data1;
+		netif_rx_ni(skb);
+	} else {
+		netdev_err(net, "cannot allocate error skb\n");
+	}
+}
+
+static void mcp2515_tx_work_handler(struct work_struct *ws)
+{
+	struct mcp2515_device *priv = container_of(ws, struct mcp2515_device, tx_work);
+	struct net_device     *net = priv->net;
+	struct can_frame      *frame;
+
+	mutex_lock(&priv->mcp_lock);
+	if ( (priv->can.state == CAN_STATE_BUS_OFF) &&
+				(priv->can.restart_ms == 0) ){
+		priv->force_quit = 1;
+		can_bus_off(net);
+		DBG_ERROR("CAN_STATE_BUS_OFF call hw_sleep\n");
+		mcp2515_hw_sleep(priv);
+	}
+	if (priv->tx_skb) {
+		if (priv->can.state == CAN_STATE_BUS_OFF) {
+			mcp2515_clean(net);
+		} else {
+			frame = (struct can_frame *)priv->tx_skb->data;
+
+			if (frame->can_dlc > CAN_FRAME_MAX_DATA_LEN)
+				frame->can_dlc = CAN_FRAME_MAX_DATA_LEN;
+			priv->tx_len = 1 + frame->can_dlc;
+			can_put_echo_skb(priv->tx_skb, net, 0);
+			mcp2515_hw_tx(priv, frame, 0);
+//TODO mod gest tx			priv->tx_skb = NULL;
+		}
+	}
+	mutex_unlock(&priv->mcp_lock);
+}
+
+static void mcp2515_restart_work_handler(struct work_struct *ws)
+{
+	struct mcp2515_device *priv = container_of(ws, struct mcp2515_device, restart_work);
+	struct net_device *net = priv->net;
+
+	mutex_lock(&priv->mcp_lock);
+	if (priv->after_suspend) {
+		mdelay(10);
+		mcp2515_hw_reset(priv);
+		mcp2515_setup(net, priv);
+		if (priv->after_suspend & AFTER_SUSPEND_RESTART) {
+			mcp2515_set_normal_mode(priv);
+		} else if (priv->after_suspend & AFTER_SUSPEND_UP) {
+			netif_device_attach(net);
+			mcp2515_clean(net);
+			mcp2515_set_normal_mode(priv);
+			netif_wake_queue(net);
+		} else {
+			mcp2515_hw_sleep(priv);
+		}
+		priv->after_suspend = 0;
+		priv->force_quit = 0;
+	}
+
+	if (priv->restart_tx) {
+		priv->restart_tx = 0;
+		mcp2515_write_reg(priv, TXBCTRL(0), 0);
+		mcp2515_clean(net);
+		netif_wake_queue(net);
+		mcp2515_error_skb(net, CAN_ERR_RESTARTED, 0);
+	}
+	mutex_unlock(&priv->mcp_lock);
+}
+
+static int mcp2515_open(struct net_device *net)
+{
+	struct mcp2515_device  *priv = netdev_priv(net);
+	int                     ret;
+
+	ret = open_candev(net);
+	if (ret) {
+		DBG_ERROR("unable to set initial baudrate!\n");
+		return ret;
+	}
+
+	mutex_lock(&priv->mcp_lock);
+
+	priv->force_quit = 0;
+//TODO mod gest tx modificare in un unico flag
+	priv->tx_skb = NULL;
+	priv->tx_len = 0;
+
+	/* set mailbox Tx, Rx address */
+	if(!mcp2515_drv.pcie_bar0){
+		mcp2515_drv.pcie_bar0 = irq_detach();
+		if (!mcp2515_drv.pcie_bar0) {
+			DBG_ERROR("failed to set callback function\n");
+			close_candev(net);
+			goto open_unlock;
+		}
+		mcp2515_drv.mbrx_base = mcp2515_drv.pcie_bar0 + SPI_MCP2515_MB_RX_BASE;
+		mcp2515_drv.mbtx_base = mcp2515_drv.pcie_bar0 + SPI_MCP2515_MB_TX_BASE;
+		DBG_PRINT("Mailbox Rx address %p Tx address %p\n",
+							mcp2515_drv.mbrx_base, mcp2515_drv.mbtx_base);
+		/* empty tx mailbox */
+		MB_CMD_READ(mcp2515_drv.mbrx_base);
+	}
+	/* set device SPI register base address */
+	if (priv->index == 0) {
+		priv->spi_mcp2515_base = mcp2515_drv.pcie_bar0 + SPI_MCP2515_0_BASE;
+	} else {
+		priv->spi_mcp2515_base = mcp2515_drv.pcie_bar0 + SPI_MCP2515_1_BASE;
+	}
+	DBG_PRINT("device %d:net device %p:SPI MCP2515 address %p\n",
+	          priv->index,
+	          (void*)net,
+	          priv->spi_mcp2515_base);
+
+	/* Attach interrupt hook */
+	ret = (int)irq_attach();
+	if (!ret) {
+		DBG_ERROR("failed to set callback function\n");
+		close_candev(net);
+		goto open_unlock;
+	}
+
+	if ( !(priv->flags & FLG_HW_PROBE_DONE) ) {
+		/* Here is OK to not lock the MCP, no one knows about it yet */
+		DBG_PRINT("device %d:net device %p:mcp2515_hw_probe\n",
+		          priv->index, (void*)net);
+		if (!mcp2515_hw_probe(priv)) {
+			DBG_ERROR("device %d:net device %p:fail on mcp2515_hw_probe\n",
+			          priv->index, (void*)net);
+			ret = -ENODEV;
+			close_candev(net);
+			goto open_unlock;
+		}
+		mcp2515_hw_sleep(priv);
+		priv->flags |= FLG_HW_PROBE_DONE;
+	}
+
+	priv->wq = create_freezable_workqueue("mcp2515_wq");
+	INIT_WORK(&priv->tx_work, mcp2515_tx_work_handler);
+	INIT_WORK(&priv->restart_work, mcp2515_restart_work_handler);
+
+	DBG_PRINT("device %d:call reset\n", priv->index);
+	ret = mcp2515_hw_reset(priv);
+	if (ret) {
+		mcp2515_open_clean(net);
+		DBG_ERROR("device %d:failed to reset hw\n", priv->index);
+		goto open_unlock;
+	}
+	DBG_PRINT("device %d:call setup\n", priv->index);
+	ret = mcp2515_setup(net, priv);
+	if (ret) {
+		mcp2515_open_clean(net);
+		DBG_ERROR("device %d:failed to setup\n", priv->index);
+		goto open_unlock;
+	}
+	DBG_PRINT("device %d:call set normal mode\n", priv->index);
+	ret = mcp2515_set_normal_mode(priv);
+	if (ret) {
+		mcp2515_open_clean(net);
+		DBG_ERROR("device %d:failed to set normal mode\n", priv->index);
+		goto open_unlock;
+	}
+
+	can_led_event(net, CAN_LED_EVENT_OPEN);
+
+	netif_wake_queue(net);
+
+open_unlock:
+	mutex_unlock(&priv->mcp_lock);
+	return ret;
+}
+
+static const struct net_device_ops mcp2515_netdev_ops = {
+	.ndo_open = mcp2515_open,
+	.ndo_stop = mcp2515_stop,
+	.ndo_start_xmit = mcp2515_hard_start_xmit,
+};
+
+static struct net_device* mcp2515_can_create(int index)
+{
+	struct net_device      *net;
+	struct mcp2515_device  *priv;
+	int                     freq;
+	int                     ret = -ENODEV;
+
+	DBG_PRINT("device %d:alloc_candev\n", index);
+
+	/* Allocate can/net device */
+	net = alloc_candev(sizeof(struct mcp2515_device), TX_ECHO_SKB_MAX);
+	if (!net) {
+		DBG_ERROR("device %d:insufficent memory\n", index);
+		return NULL;
+	}
+	mcp2515_drv.net[index] = net;
+
+	net->netdev_ops = &mcp2515_netdev_ops;
+	net->flags |= IFF_ECHO;
+
+	priv = netdev_priv(net);
+	DBG_PRINT("device %d:net @ %p; priv @ %p\n", index, (void*)net, (void*)priv);
+
+	freq = 24*1000*1000;
+	priv->can.bittiming_const    = &mcp2515_bittiming_const;
+	priv->can.do_set_mode        = mcp2515_do_set_mode;
+	priv->can.clock.freq         = freq / 2;
+	priv->can.ctrlmode_supported = CAN_CTRLMODE_3_SAMPLES |
+	                               CAN_CTRLMODE_LOOPBACK  |
+	                               CAN_CTRLMODE_LISTENONLY;
+	priv->net = net;
+
+	DBG_PRINT("device %d:net device %p:mutex_init\n", index, (void*)net);
+	mutex_init(&priv->mcp_lock);
+	init_waitqueue_head(&priv->spi_wait);
+
+	/* If requested, allocate DMA buffers */
+	if (mcp2515_enable_dma) {
+		DBG_PRINT("device %d:allocate DMA buffers\n", index);
+		/* Minimum coherent DMA allocation is PAGE_SIZE, so allocate *
+		 * that much and share it between Tx and Rx DMA buffers.     */
+		priv->spi_tx_buf = dma_alloc_coherent(NULL,
+		                                      PAGE_SIZE,
+		                                      &priv->spi_tx_dma,
+		                                      GFP_DMA);
+		if (priv->spi_tx_buf) {
+			priv->spi_rx_buf = (priv->spi_tx_buf + (PAGE_SIZE / 2));
+			priv->spi_rx_dma = (dma_addr_t)(priv->spi_tx_dma + (PAGE_SIZE / 2));
+		} else {
+			/* Fall back to non-DMA */
+			mcp2515_enable_dma = 0;
+		}
+	}
+
+	/* Allocate non-DMA buffers */
+	if (!mcp2515_enable_dma) {
+		DBG_PRINT("device %d:allocate non DMA buffers\n", index);
+		priv->spi_tx_buf = kzalloc(SPI_MCP2515_BUF_SIZE, GFP_KERNEL);
+		if (!priv->spi_tx_buf) {
+			ret = -ENOMEM;
+			goto error_probe;
+		}
+		priv->spi_rx_buf = kzalloc(SPI_MCP2515_BUF_SIZE, GFP_KERNEL);
+		if (!priv->spi_rx_buf) {
+			ret = -ENOMEM;
+			goto error_probe;
+		}
+	}
+	priv->index = index;
+
+	ret = register_candev(net);
+	if (ret) {
+		goto error_probe;
+	}
+
+	devm_can_led_init(net);
+
+	DBG_PRINT("device %d:net device %s %p:created\n", index, net->name, (void*)net);
+
+	return net;
+
+error_probe:
+	if (mcp2515_enable_dma){
+		DBG_ERROR("free dma buffers\n");
+		dma_free_coherent(NULL,
+		                  PAGE_SIZE,
+		                  priv->spi_tx_buf, priv->spi_tx_dma);
+	} else {
+		DBG_ERROR("free buffers\n");
+		kfree(priv->spi_tx_buf);
+		kfree(priv->spi_rx_buf);
+	}
+
+	DBG_ERROR("free candev\n");
+	free_candev(net);
+	return NULL;
+}
+
+static int mcp2515_can_remove(struct net_device *net)
+{
+	struct mcp2515_device *dev = netdev_priv(net);
+
+	DBG_PRINT("unregister_candev\n");
+	unregister_candev(net);
+
+	if (mcp2515_enable_dma) {
+		DBG_PRINT("free DMA buffers\n");
+		dma_free_coherent(NULL,
+		                  PAGE_SIZE,
+		                  dev->spi_tx_buf,
+		                  dev->spi_tx_dma);
+	} else {
+		DBG_PRINT("free buffers\n");
+		kfree(dev->spi_tx_buf);
+		kfree(dev->spi_rx_buf);
+	}
+
+	DBG_PRINT("free_candev\n");
+	free_candev(net);
+
+	return 0;
+}
+
+static __init int mcp2515_init(void)
+{
+	int i;
+
+	DBG_PRINT("MCP2515 driver\n");
+	mutex_init(&mcp2515_drv.spi_lock);
+	for (i=0; i<MCP2515_NUM_DEV; i++) {
+		DBG_PRINT("MCP2515 create device %d\n", i);
+		mcp2515_drv.net[i] = mcp2515_can_create(i);
+		if ( !mcp2515_drv.net[i] ) {
+			DBG_ERROR("MCP2515 %d net device creation failed\n", i);
+			if (i) {
+				mcp2515_can_remove(mcp2515_drv.net[0]);
+			}
+			return -1;
+		}
+		DBG_PRINT("MCP2515 net device %s #%d @ %p created\n",
+							mcp2515_drv.net[i]->name, i, (void*)mcp2515_drv.net[i]);
+	}
+	return 0;
+}
+
+static __exit void mcp2515_exit(void)
+{
+	int i;
+
+	irq_attach();
+	for (i=0; i<MCP2515_NUM_DEV; i++) {
+		mcp2515_can_remove(mcp2515_drv.net[i]);
+	}
+	DBG_PRINT("unregister isr hook\n");
+	irq_detach();
+}
+
+module_init(mcp2515_init);
+module_exit(mcp2515_exit);
+
+MODULE_AUTHOR("ipTronix");
+MODULE_DESCRIPTION("Microchip MCP2515 CAN driver");
+MODULE_LICENSE("GPL v2");
